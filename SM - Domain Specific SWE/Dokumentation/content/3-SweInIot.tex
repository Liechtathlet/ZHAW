\chapter{Software Engineering in der Domäne "`Internet of Things"'} \label{chap:sweInIot}
In diesem Kapitel werden die Anforderungen, Eigenheiten und Unterschiede des Software Engineering in der Domäne "`Internet of Things"' im Vergleich zur "`Standard Domäne"' aufgezeigt.

Die Struktur dieses Kapitels orientiert sich an der Struktur des Buches "`Software Engineering Body of Knowledge"' \cite{B:IEEE:SWEBOOK}.



\subsection{Software Requirements}
Im Requriements Engineering der Software Requriements gibt es im Vergleich zur Standard Domäne nur wenige Unterschiede. Der Hauptunterschied liegt darin, dass gewisse Anforderungen implizit durch die Domäne vorgegeben sind. Betroffen sind dabei sowohl Anforderungen auf Ebene Produkt, als auch auf Ebene Prozess. Nachfolgend werden einige Beispiele möglicher impliziter Anforderungen aufgelistet.

\begin{itemize}
\item Kostengünstig
\item Energieeffizient
\item Betrieb ohne Stromanschluss
\item Massiv skalierbar
\item Lange Lebensdauer
\item Verlässlich
\item Vertrauenswürdig
\item Möglichkeit für das Einspielen von Updates
\end{itemize}

Die Anforderungen auf Ebene Produkt haben einen direkten und starken Einfluss auf die Hardware, die verwendet werden kann oder verwendet werden soll. Je nach dem steuern die Anforderungen an das Produkt die Hardware oder es gibt explizite Anforderungen an die Hardware, welche die Anforderungen an die Software beeinflussen und gegebenenfalls einschränken. 

Im Bereich \gls{acr:IOT} ist es wichtig, dass die Anforderungen genau spezifiziert und korrekt umgesetzt werden. Eine spätere Korrektur kann sich unter Umständen als schwierig herausstellen. Wurden zum Beispiel für ein Sensor-Netzwerk mehrere Tausend Sensoren verteilt, welche nicht direkt mit dem Internet kommunizieren können, kann der Update-Prozess sehr aufwändig sein. Daher müssen auch sämtliche Anforderungen umgesetzt werden, welche zwingend benötigt werden.

Weitere Herausforderungen sind der Einsatz in einem unbekannten Umfeld (Umwelt \& Technisch) und die schwierige Feststellbarkeit von Fehlern. Liefert zum Beispiel ein Sensor konstant falsche Werte, kann dies aus der Ferne, beziehungsweise ohne Vergleichswert praktisch nicht festgestellt werden. Ein mögliches Szenario wäre ein Sensor, welche in einer Fertigungsanlage auf einem Fliessband die Stückzahlen erfasst. Sind diese nun nicht korrekt und ein Backe-End-System bestellt auf Basis dieser Stückzahlen Nachschub für Einzelteile kann dies massive Auswirkungen haben.

Neben den Anforderungen von Seiten des Kunden, beziehungsweise des Herstellers, gibt es auch noch regulatorische und gesetzliche Anforderungen zu erfüllen. Hier stellt sich zum Beispiel die Frage der Haftung, wenn ein System auf Basis der Informationen eines anderen Systemes eine Aktion auslöst und die gelieferten Informationen nicht korrekt sind.



\subsection{Software Design}
berücksichtigung design hw, nicht viel spielraum, u.u. keine frameworks, hochsprachen
Software Design um Anforderungen zu erfüllen, Funktionalität: as much as , as less as possible, wenig / einfache Funktionalität (Endgerät), Gateway etwas mehr, schlank

Effiziente Nutzung Ressourcen (Prozesse Threads) Real-Time-OS, Verteilung sW auf HW, Wie Komponenten kommunizieren, Evtl. Einsatz on Middleware

I.d.R: Keine Präsentations-Schicht, Data-Persistence: Vorhaltung nicht sinnvoll --> Realtime informationen, 

Berücksichtigung: Protokolle, Standards, Last-Anforderungen (Matching Standards / Protokolle und HW mit Anforderungen)

Machine To Machine Connectivity, Wireless, API-Evolution in MInd



\subsection{Software Construction} Chapter 4 / S. 61
Je nach Anwendungsbereich: Hardwarenahe, Optimierung
Für die Entwicklung von Anwendungen für \gls{acr:IOT}-Geräte können
https://www.rti.com/company/careers/software-engineer.html grundsätzlich


Firmware für Spezifische Hardware, Adressierung Netzwerk- und Verbindungsprobleme, Security



\subsection{Software Testing}
Wenn bei Consumer: Update evtl. schwierig, Fehlfunktion schwerwiegend,

Test: Nachbildung physische Umgebung, komplexe Szenarien, Netzwerk-Anforderungen, 



\subsection{Software Maintenance}
Schwierig,...
Immer connected --> regular updates, wenn nicht regelmässig upgedatet --> Verlust kritischer Funktionalität, Continuous Delivery

Nicht überall möglich, Low-Bandwith, Hardware-Near Devices



\subsection{Software Configuration Management}



\subsection{Software Engineering Management}



\subsection{Software Engineering Process}
Defect Tracking, small scale projects, fast product turnaroudn, 



\subsection{Software Engineering Tools and Methods}



\subsection{Software Quality}
Höhere Qualität notwendig








Wetter, Physische Einflüsse, Durch das Gerät erzeugte Hitze, Lange Lebensdauer

SW Muss: Skalierbar für breite Palette an verschiedenen Gerätekategorien
Modular sein --> nur Auswahl (RAM-Footprint)
Verbunden (Daten rein/raus)
Verlässlich:Zertifizierung für kritische Applikationen


http://ercim-news.ercim.eu/en98/special/internet-of-things-a-challenge-for-software-engineering
http://link.springer.com/chapter/10.1007%2F978-3-642-31479-7_47#page-1

Layer: Transport-Layer: TCP zum Teil overkill für IOT-Device --> UDP
UDP: beser geeignet für relatime-data, TCPS Acknowledgment and retransmission unnützer overhad für solche Anwendungen (Stück sprache nicht rechtzeitig übermittelt -> Retransmission sinnlos), 


Klassische Ansätze nicht alle geeignet für IoT, 

Service-based Application: composition and orchestration of Services



Evtl. Struktur nach kategorie: Connectivity, Management, Security, API, ...

Real-Time schwierig, trade off datenverlust, oft TCP als Datenbasis -> messung mit Quality of service besser

http://postscapes.com/internet-of-things-software-guide
	https://www.silabs.com/Support%20Documents/TechnicalDocs/bringing-the-internet-of-things-to-life.pdf
http://www.datamation.com/open-source/35-open-source-tools-for-the-internet-of-things-1.html
https://blog.profitbricks.com/top-49-tools-internet-of-things/
http://www.businesscloudnews.com/2015/05/14/samsung-announces-open-internet-of-things-platform/
https://www.rti.com/company/news/iot-connectivity-webinar.html
http://www.iotsworldcongress.com/documents/4643185/4c3cc80c-03b0-41be-baf0-6a1a0fa7db07
%https://www.mapr.com/blog/key-requirements-iot-data-platform#.VVuNi3W1FBc


SWE:
https://hal.inria.fr/hal-01064075/document
http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=7030178
http://www.cio.com/article/2843814/developer/how-to-develop-applications-for-the-internet-of-things.html
http://www.appdevelopersalliance.org/internet-of-things/
%http://www.fit.fraunhofer.de/de/fb/ucc/lehre/scrum-based_softwaredevelopmentofinternet-of-thingsapplications.html
%http://insights.wired.com/profiles/blogs/winning-strategies-software-development-for-the-internet-of#axzz3anWNtzAE

http://link.springer.com/chapter/10.1007%2F978-3-642-36818-9_6#page-1


Protokolle / Standards für verschieden Phasen: Collect Data, Access, Process, Collect, Control / distribute

\section{Programmiersprachen}

C, C++, Zum Teil: Java --> OS benötigt, von daher C,C++ und Java
Java benötigt nicht zu vernachlässigendd Ressourcen, z.B. Oracle Java ME Embedded: Memory: 130 KB - 700 KB, ROM: 350 KB - 2000 KB, + Netzwerkstack, Kernel, nicht mehr ein embedded system, Java nur auf fähigeren, teurerern Systemen

\subsection{Assembler}
Eine Implementation in Assembler kann unter bestimmten Voraussetzungen die beste Lösung für ein bestimmtes Problem sein. In der Regel wird der Assembler-Ansatz gewählt, wenn das Programm so effizient und sparsam wie möglich ablaufen und mit so wenig Ressourcen als möglich auskommen soll.



\subsection{C / C++}


\subsection{Java / .NET}
Für die Implementation kann es durchaus sinnvoll sein eine Hochsprache, wie Java oder .NET C\# einzusetzen. 

\section{Protokolle und Standards}

Grafik: http://electronicdesign.com/embedded/understanding-protocols-behind-internet-things 

Viele Implementationen:
MQTT: Collect device data, send to server, D2S
CoAP
XBEE
XMPP: Access device data, connect device to people, D2S
DDS: Distribute Device Data, fast bus for integrating intelligent machines (D2D)
HTTP
AMQP (IOT-Client-Seitig?), Queuing system to connect servers to servers (S2S)

https://www.sparkfun.com/news/1705
http://micrium.com/iot/internet-protocols/

\subsection{MQTT}
Message Queue Telemetry Transport, Device Data Collection, Haupfaufgabe: Fernmessung, Remote Monitoring, Datensammeln und an Infrastruktur ausliefern, Anwendungszweck: Grosse Netzwerke von kleinen Geräte, welche überwacht und kontrolliert werden müssen. Basis: TCP (kein Datenverlust)

Publish / Subscribe, central Server, Subscribe to Topics, MQTT-Broker, Notify all connected devices, 
Hub and Spoke System: Geräte --> Data Verbindung zu Server, System ist designt, um daten an enterprise technologien weiter zu geben (z.B. ESB)

Kein Protokoll für D2D, nicht mehrere Empfänger der Daten, wenige Kontrollmöglichkeiten, muss nicht schnell sein --> kein rela time (sekunden)

Ziel: Conserve Power and Management
Bsp: ÖL Pipeline, Energieverbrauch Überwachung, Licht-Kontrolle

Lightweight packet structure, dokumentation auf einer Seite


Wann: Thing of it as a Collection?  Wenig Device2Device Kommunikation? Sehr viele Geräte?, Sehr kleine Geräte? 

\subsection{XMPP}
Ursprünglich: Jabber, entwickelt für Instant messaging
Extensible Messaging and Presence Protocol

Text-Kommunikation zwischen Punkten

XML, über TCP (oder HTTP over TcP?)

Stärke: Adressierungs-Schema: name@domain.com, Security, Skalierbarkeit 
--> Ideal für Consumer-Oriented applications

Einfacher Weg Gerät zu adressieren, nicht schnell --> Polling oder Check for Updates on demand, 

Einsatz: z.B. Heimautoation --> Thermostat mit Web verbinden

Wann: Use the word "`my"'?, Wenige Verbindungspunkte in grossem Netz? Speed / CPU nicht wichtig? Immer Verbunden?

\subsection{DDS}
Data Distribution Service, Geräte welche direkt Geräte-Daten verwenden, Verteilung zu anderen Geräten, Interaktion mit Infrastruktur unterstützt, Daten-zentrierter Middleware-Standard, Wurzeln: High-Performance Verteidigung, Industrie, Embeddedd Applications, effektiv: millionen von nachrichten pro sekunde zu mehreren gleichzeitigen empfängern


Publish, Subscribe Architecture

Unterschied: Daten an Infrastruktur oder an anderes Gerät, Geräte sind schnell, mit vielen Geräten kommunizieren, TCP Point to Point to restriktiv, DDS: Detailierte qualitiy of service conrol, multicast, konfigurierbare verfügbarkeit, Redundanz

Filter und Selektion von Daten, bzw. Bestimmung was wohin geht

Direct Device-to-device bus, relational data model, ähnlich Datenbank, 

Z.B.: Militär, Windparks, Asset-Tracking, Fahrzeug Test und Sicherheit


Wann: Chaos / Desaster wenn für 5min offline?, Performance sehr wichtig (ms / us) / mehr als 100 Anwendungen / mehr als 10'000 Datenwerte, code mehr als 3 Jahre entwickelt?
\subsection{AMQP}
Advanced Message Queuing Protocol, ab und zu: IOT-Protokoll, transaktionsbasierte Nachrichen zwischen Servern, message-centric-middleware, proces thousands of reliable queued transactions, Fokus: kein Nachrichtenverlust, Publishers --> Exchanges, queues to subscribers: TCP, acknowledge acceptance of message, optional transaction mode with formal multiphase commit sequence

Hauptsächlich: Business messaging, device - back-office data centers

IOT: appropriate for control plane oder server-basierte analyse funktionen

Wann: Verteilung von Arbeit / nicht information?, Nur a zu B senden? Speed / CPU nicht wichtig? Nichts darf verloren gehen?
\subsection{HTTP}
Basis für Client-Server-Model im Web, Sichere Methode: auf Device nur Client implementiersen

\subsection{WebSocket}
Protokoll, Full-Duplex Communication über einzelne TCP-Verbindung zwischen Client und Server, Zeilt HTML5 Spec

\subsection{CoAP}
Web-Protokolle z.T. zu schwer für IOT-Geräte, Constrained Application Protocol for low-power and constrained networks, RESTful protocol, semantisch an HTTP ausgerichtet, 1:1 Mapping von / zu HTTP

UDP, + einige nachgebildete TCP-Funktionen, Request / Responses: Asynchron via CoAP Messages, Header, Method, Status Codes binary encoded, Reduktion Overhead, Caching abhängig von Response-Code (HTTP: Request Method)

Comparison of Protocol-Stacks: http://micrium.com/iot/internet-protocols/

Leichtgewichtige Alternative zu HTTP, CoAP Packets: all around bitmapping

\subsection{Thread}
Protokolle: Thread, Netzwerk-Protokoll, Fokus: Security, Low Energy, notwendiger Chip, schon in vielen Geräten vorhanden, gestützt auf 6LoWPAN, IPv6 over Low power Wireless Personal Area Network, 


\subsection{AllJoyn}
Qualcomm entwickelt, anschliessend: Linux Foundation, AllSeen Alliance (Cisco, Microsoft, LG, HTC, ...)
Verbindung, Wartung Geräte in WLAN-Netzwerk, Kontrolle, Benachrichtungs Service, 

\section{Frameworks}
In diesem Kapitel werden einige Frameworks vorgestellt, welche ....

Frameworks --> mobile / web --> Vereinfachung Entwiclung, Abstraktion Implementations-Details, 
apache ISIS?
http://iot.eclipse.org/java/open-iot-stack-for-java.html

\subsection{Kommunikation zwischen \gls{acr:IOT}-Geräten}
AllSeen
IOTIVITY
Z-Wave






6LoWPAN, ANT, Bluetooth, DASH7, ISA100, Wireless HART, Wireless M-Bus, Z-Wave, Zigbee / Zigbee IP, EnOcean, EtherCAT, Modbus, Profinet, HomePlug, HomeGrid


Voraussetzung Zugriff Internet: IPv6 Pflicht, Non-IP Geräte; Gateway


Middleware / Platforms / OS: http://postscapes.com/internet-of-things-software-guide

Weitere-Protokolle: http://postscapes.com/internet-of-things-protocols
Tools: http://www.datamation.com/open-source/35-open-source-tools-for-the-internet-of-things-1.html

\section{middleware}
Arten: Point-To-Point, Client/Server, Publish/Subscribe, Queuing, Data-Centric