\chapter{Die Domäne "`Internet of Things"'}

\section{Einführung}
Beschreibung der Domäne

--
\section{Anforderungen an Software}
Stark von Einsatzgebiet abhängig (Kühlschrank vs. Low Energy ohne Stromversorgung)


\section{Anforderungen an die Softwarearchitektur}

\section{Anforderungen an die Programmiersprache}

----

\section{Anforderungen / Unterschiede zur "`Standard-Domäne"'}
In diesem Kapitel werden für die einzelnen Abschnitte des Software Engineering Prozesses die Anforderungen, beziehungsweise die Unterschiede, zum Software Engeineering Prozess in der "`Standard-Domäne"' aufgezeigt. Mit "`Standard-Domäne"' wird in dieser Arbeit Software Engineering im Bereich von Enterprise-Anwendungen bezeichnet.

http://ercim-news.ercim.eu/en98/special/internet-of-things-a-challenge-for-software-engineering
http://link.springer.com/chapter/10.1007%2F978-3-642-31479-7_47#page-1

Das der Begriff "`Internet of Things"' eigentlich nur ein Oberbegriff ist....
deckt dieser Begriff auch ein sehr groses Spektrum an verschiedensten Anwendungsmöglichkeiten ab.

\subsection{Software Requirements}
eindeutig, Komplexität schwierig, nachhaltig (schwieriger Update)

non-consumer-market: regulatorisches Schwierigkeiten, Remote Tracking, Kabellose Implantate, --> Requirements-Phase: Verfolgbarkeit und Prüfbarkeit, Geschickte Verisonierung, Reviews --> Sicherstellung Compliance und Erfolg
Wetter, Physische Einflüsse, Durch das Gerät erzeugte Hitze, Lange Lebensdauer

SW Muss: Skalierbar für breite Palette an verschiedenen Gerätekategorien
Modular sein --> nur Auswahl (RAM-Footprint)
Verbunden (Daten rein/raus)
Verlässlich:Zertifizierung für kritische Applikationen
\subsection{Software Design}
Schlank, Energieeffizient, einfach wartbar?

Berücksichtigung: Protokolle, Standards, Last-Anforderungen

Machine To Machine Connectivity, Wireless, API-Evolution in MInd
\subsection{Software Construction}
Je nach Anwendungsbereich: Hardwarenahe, Optimierung
Für die Entwicklung von Anwendungen für \gls{acr:IOT}-Geräte können
https://www.rti.com/company/careers/software-engineer.html grundsätzlich


Firmware für Spezifische Hardware, Adressierung Netzwerk- und Verbindungsprobleme, Security


\subsection{Software Testing}
Wenn bei Consumer: Update evtl. schwierig, Fehlfunktion schwerwiegend,

Test: Nachbildung physische Umgebung, komplexe Szenarien, Netzwerk-Anforderungen, 

\subsection{Software Maintenance}
Schwierig,...
Immer connected --> regular updates, wenn nicht regelmässig upgedatet --> Verlust kritischer Funktionalität, Continuous Delivery

Nicht überall möglich, Low-Bandwith, Hardware-Near Devices


\subsection{Software Configuration Management}


\subsection{Software Engineering Management}


\subsection{Software Engineering Process}
Defect Tracking, small scale projects, fast product turnaroudn, 

\subsection{Software Engineering Tools and Methods}


\subsection{Software Quality}
Höhere Qualität notwendig




Layer: Transport-Layer: TCP zum Teil overkill für IOT-Device --> UDP
UDP: beser geeignet für relatime-data, TCPS Acknowledgment and retransmission unnützer overhad für solche Anwendungen (Stück sprache nicht rechtzeitig übermittelt -> Retransmission sinnlos), 


Klassische Ansätze nicht alle geeignet für IoT, 

Service-based Application: composition and orchestration of Services