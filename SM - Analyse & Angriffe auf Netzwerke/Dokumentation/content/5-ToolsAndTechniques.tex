\chapter{Tools und Techniken} \label{chap:ToolsTechniques}
In diesem Kapitel werden die grundlegenden Tools und Techniken einer forensischen Analyse vorgestellt. Die Tools und Techniken werden dabei nach der Phase, in der diese eingesetzt und angewendet werden, gegliedert.




%---------------------------------------------------------------------------------------------------------------
\section{Readiness}
In diesem Kapitel werden einige Techniken und Tools aufgezeigt, welche während der Phase "`Readiness"' von Bedeutung sind.


\subsection{Datenträger löschen}
Digitale Beweise und Kopien von Images sollten immer auf leere, beziehungsweise zuvor komplett gelöschte Datenträger gesichert werden. Wird dies nicht gemacht, kann es sein, dass Rückstände / Daten von vorherigen Untersuchungen die Analyse beeinflussen.

\subsubsection{dd}
Unter Linux kann für das Löschen, genauer gesagt das Überschreiben mit Zufallswerten das Tool \textit{dd} verwendet werden.

\begin{lstlisting}
dd if=/dev/random of=/dev/<DriveToWipe>
\end{lstlisting}

\subsubsection{Weitere Tools}
\begin{itemize}
\item EnCase
\end{itemize}




%---------------------------------------------------------------------------------------------------------------
\section{Secure}
In diesem Kapitel werden einige Techniken und Tools aufgezeigt, welche während der Phase "`Secure"' von Bedeutung sind. 


\subsection{Auslesen der Zeitkonfiguration}
Die Zeitkonfiguration des Systemes wird je nach Betriebssystem und zum Teil sogar je nach Distribution an einem anderen Ort gespeichert.

Unter Ubuntu, beziehungsweise Debian-Systemen ist diese unter \textit{/etc/timezone} zu finden. Bei Red-Hat-Distributionen unter \textit{/etc/sysconfig/clock}.
Beim Auslesen der Zeitkonfiguration ist auch zu notieren, ob das System automatisch zwischen Sommer- und Winterzeit umstellt.

\begin{lstlisting}
> cat /etc/timezone
Europe/Zurich
\end{lstlisting}

Das Datum und die Uhrzeit kann über nachfolgenden Befehl ausgelesen werden. Zu beachten ist hier, dass eine statisch vorkompilierte Version des Befehsl verwendet wird.
\begin{lstlisting}
> date
Fre Mai 29 08:00:00 CEST 2015
\end{lstlisting}



\subsection{Bestimmung der Linux-Distribution}
Jede Linux-Distribution hat ihre Eigenheiten. Dazu zählen unter anderem Befehle, Speicherorte, Methoden für Tracking und Auditierung der User Aktivität und das Logging von System Events.

Unter vielen Distributionen befindet sich unterhalb des Ordners \textit{/etc} ein File, welches die Versions-Informationen enthält.\\
\begin{lstlisting}
> ls /etc | grep -E "`release|version"'
debian_version
lsb-release
lsb-release.dpkg-dist
os-release
upstream-release

> cat /etc/debian_version
jessie/sid

> cat /etc/os-release
NAME="Ubuntu"
VERSION="14.04.2 LTS, Trusty Tahr"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 14.04.2 LTS"
VERSION_ID="14.04"
HOME_URL="http://www.ubuntu.com/"
SUPPORT_URL="http://help.ubuntu.com/"
BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"
\end{lstlisting}

Ist kein entsprechendes File vorhanden kann das Logon-Banner oder die Log-Einträge unter \textit{/var/log/dmesg} oder \textit{/var/log/messages} allenfalls Hinweise zur Distribution enthalten:\\
\begin{lstlisting}
> cat /etc/issue
Linux Mint 17 Qiana \n \l

> cat /var/log/dmesg
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Initializing cgroup subsys cpuacct
[    0.000000] Linux version 3.13.0-49-generic (buildd@akateko) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #83-Ubuntu SMP Fri Apr 10 08:00:00 UTC 2015 (Ubuntu 3.13.0-49.83-generic 3.13.11-ckt17)
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-3.13.0-49-generic root=UUID=ee905b77-1264-477b-9942-23bd448df95c ro quiet splash acpi_backlight=vendor acpi_osi=Linux vt.handoff=7
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000]   Centaur CentaurHauls
[    0.000000] e820: BIOS-provided physical RAM map:
\end{lstlisting}

Oft gibt auch der verwendete Package-Manager ein Hinweis auf die verwendete Distribution:\\
\begin{itemize}
\item Ubuntu Linux: APT, Synaptic
\item Red Hat / Fedora Linux: RPM
\item Gentoo Linux: Portage / Emerge
\item SUSE Linux: YaST
\item Debian Linux: APT
\end{itemize}



\subsection{Shutdown eines Systemes}
Ein laufendes System kann grundsätzlich auf zwei verschiedene Arten heruntergefahren werden. Zum einen kann ein normaler, regulärer Shutdown des Systemes durchgeführt werden. Dabei werden sämtliche Datei gespeichert und temporäre Daten gelöscht / aufgeräumt. Das System befindet sich anschliessend in einem sauberen / lauffähigen Zustand. Während dem Shutdown werden jedoch bei zahlreichen Dateien die Zeitstempel verändert und sämtliche Daten welche sich im Arbeitsspeicher befinden gehen verloren. Dies kann unter Umständen die Analysearbeiten erschweren oder im schlimmsten Fall wichtige Beweise vernichten.

Die andere Methode ein System herunterzufahren ist der harte Shutdown. Beim harten Shutdown wird das System von der Stromversorgung getrennt, ohne das dieses vorher heruntergefahren wurde. Mit diesem Vorgehen wird sichergestellt, dass die Zeitstempel unverändert bleiben und die temporären Daten erhalten bleiben. Auch ist die Wahrscheinlichkeit da, dass auf der Festplatte eine Auslagerungsdatei vorhanden ist, welche analysiert werden kann. Die Extraktion und Analyse dieser Daten ist jedoch sehr aufwändig. Diese Methode des Shutdowns kann bei gewissen Dateisystemen zu irreparablen Schäden führen. Daher ist vorgängig abzuwägen, ob ein harter Shutdown sinnvoll und verkraftbar ist.

Bei beiden Varianten ist die Zeit der Durchführung und die Art des Shutdowns zu protokollieren.

Die Möglichkeiten den Inhalt des Arbeitsspeichers zu sichern, werden im nachfolgenden Kapitel vorgestellt.



\subsection{Erstellen von Hashes} \label{subsec:ToolsTechniques:Secure:Hash}
Für die Sicherung von Daten ist die Erstellung von Hashes von essentieller Bedeutung. Jede Datei, Partition oder ähnlich sollte vor und nach der Sicherung gehasht werden, um sicherzustellen, dass diese durch den Sicherungsvorgang nicht verändert wurde. Auch Protokolle, Dokumentation, Ergebnisse der Analyse, etc. sollten immer mit einem Hash versehen und geprüft werden.

\subsubsection{md5sum}
Mit folgendem Befehl können MD5-Hashes von einzelnen Dateien erstellt werden. Es stehen unter anderm MD2, MD4, MD5, SHA und SHA1 als Algorithmen zur Verfügung.

\begin{lstlisting}
> md5sum <FileName>
\end{lstlisting}

\subsubsection{md5deep}
Mit dem Tool "`md5deppe"' können Hashes von Ordnerinhalten rekursiv erstellt werden. Es können dabei Hashes mit dem MD5, dem SHA1, dem SHA256, dem Tiger und Whirlpool Algorithmus erstellt werden.

\begin{lstlisting}
> md5depp -r <PathToDirectory>
\end{lstlisting}



\subsection{Sicherung des Arbeitsspeicher-Inhaltes}
Bei der Sicherung von Arbeitsspeicher-Inhalten ist grundsätzlich zu beachten, dass die verwendeten Tools und Techniken einen kleinen Memory-Footprint aufweisen. Je mehr Arbeitsspeicher ein Tool verwendet, desto mehr wichtige Daten und somit auch Beweise gehen verloren. Ein weiterer wichtiger Punkt der beachtet werden soll ist, dass die Sicherung nicht im User-Mode, sondern im Kernel-Mode erfolgt. So ist sichergestellt, dass der gesamte Inhalte des Arbeitsspeichers gesichert werden kann. Andernfalls können aufgrund von Berechtigungseinschränkungen nicht alle Daten gesichert werden.

\subsubsection{Kein Zugriff auf das Betriebssystem vorhanden} \todo{Evtl. weitere Details und Beispiele}
%http://www.forensicmag.com/articles/2013/05/catching-ghost-how-discover-ephemeral-evidence-through-live-ram-analysis
%http://forensicswiki.org/wiki/Tools:Memory_Imaging
Grundsätzlich gilt, dass der Inhalt des Arbeitsspeichers beim herunterfahren des Systems verloren geht. Studien haben gezeigt, dass die Inhalte des Arbeitsspeichers noch bis zu mehreren Minuten nach dem Verlust der Stromversorgung im Arbeitsspeicher vorhanden sind. 

Für die Sicherung des Arbeitsspeichers ohne zugriff auf das Betriebssystem können unter anderem folgende Techniken eingesetzt werden:
\begin{itemize}
\item Kühlung des physikalischen Bausteins\\
Bevor das System mit einem harten Shutdown heruntergefahren wird, wird das Gehäuse des Systems geöffnet und der Arbeitsspeicher mit einem Stickstoffspray auf -50 Grad Celsius herutner gekühlt. Nach dem harten Shutdown wird der Arbeitsspeicher ausgebaut und in einem Analyse-System  eingebaut. Das Analyse-System wird mit einer Spezialsoftware gestartet, welche den gesamten Arbeitsspeicher auf einen anderen Datenträger sichert.

\item Firewire-Attacke\\
Bei der Firewire-Attacke wird eine Schwachstelle der Firewire-Schnittstelle ausgenutzt, um Inhalte des Arbeitsspeichers zu sichern. Die Schwachstelle kann jedoch nur unter bestimmten Bedingungen ausgenutzt werden und es kann nur eine begrenzte Menge an Arbeitsspeicher ausgelesen werden. Weitere Informationen zur Firewire-Attacke sind hier zu finden: \url{https://blogs.gnome.org/muelli/2010/04/reading-ram-using-firewire/}, \url{http://link.springer.com/chapter/10.1007%2F978-3-642-23602-0_14#page-1}
\end{itemize}



\subsection{Forensische Duplikation}
Bei einer forensischen Duplikation sollte der Quelldatenträger immer Bit-Weise kopiert werden. Zusätzlich ist sicherzustellen, dass der Quelldatenträger Read-Only gemountet oder über einen Writeblocker angeschlossen ist. Ein Writeblocker verhindert physisch, dass Daten auf einen Datenträger geschrieben werden können. Es ist zu empfehlen grundsätzlich immer einen Writeblocker auf Hardware-Basis zu verwenden.

Die Sicherung kann auf folgende Arten durchgeführt werden:
\begin{itemize}
\item Auf einem Live-System\\
Die Duplikation des Datenträgers erfolgt unter Einsatz eines Software-Writeblockers auf dem Live-System
\item Auf dem zu untersuchenden System\\
Die Duplikation erfolgt über eine Live-CD, nachdem das System heruntergefahren wurde. Für die Duplikation wird ein Writeblocker auf Software- oder Hardware-Basis eingesetzt.
\item Auf dem Analyse-System\\
Die Duplikation erfolgt auf dem Analyse-System. Für die Duplikation wird ein Writeblocker auf Software- oder Hardware-Basis eingesetzt.
\item Hardware-Imager\\
Die Duplikation erfolgt durch ein auf Imaging spezialisierte externe Hardware.
\end{itemize}

Das Image des Quelldatenträgers kann entweder auf einem separaten, sterilen Datenträger oder über ein Netzwerk auf einen Server gesichert werden. Bei der Duplikation ist sicherzustellen, dass auch versteckte Bereiche des Datenträgers, wie Host Protected Areas, Device configuration Overlays gesichert werden.

\subsubsection{Einsatz von Standard-Linux Tools}

\textbf{Mounten des Zieldatenträgers}
\begin{lstlisting}
> mount -t <Dateisystem> <PathToDisk> <MountPoint>
\end{lstlisting}

\textbf{Sicherung der Partitionstabelle}
\begin{lstlisting}
> fdisk -l <PathToDisk> > <MountPoint>/<FileName.fdisk>

> parted -l <PathToDisk> > <MountPoint>/<FileName.fdisk>
\end{lstlisting}

\textbf{Generierung eines Hashes}\\
Vor der Duplikation wird ein Hash des zu sichernden Datenträgers / Partition gemäss Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash} erstellt und dokumentiert.

\textbf{Duplikation}
\begin{lstlisting}
> dd conv=noerror bs=512k if=<PathToDisk> of=<MountPoint>/<FileName.dd>
\end{lstlisting}

\textbf{Generierung eines Hashes}\\
Nach der Duplikation wird ein Hash des zu sichernden Datenträgers / Partition gemäss Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash} erstellt und mit dem dokumentierten Hash verglichen. Dies stellt sicher, dass der Datenträger während der Duplikation nicht unbemerkt verändert wurde. Anschliessend ist vom erstellten Image ebenfalls ein Hash zu erstellten, welcher mit dem dokumentierten verglichen werden muss. Ist dieser mit dem dokumentierten Hash identisch, wurde der Datenträger / die Partition korrekt dupliziert.

Im Anschluss muss das Verfahren für jede verfügbare Partition wiederholt werden.

\textbf{Transfer des Images via Netzwerk}
\begin{lstlisting}
> nc -l -p 8000 |dd of=<MountPoint>/<PathToImage>
\end{lstlisting}

\textbf{Transfer des Images via Netzwerk (Verschlüsselt)}
\begin{lstlisting}
> cryptcat -k <Pssword> -l -p 8000 |dd of=<MountPoint>/<PathToImage>
\end{lstlisting}

\subsubsection{Weitere Tools}
\todo{Weitere Tools}
Adepto: Wizard für die gängigen Tools




\subsection{Verifikation eines forensischen Duplikates oder eines Beweisstückes}
Vor und nach der Verwendung eines forensischen Duplikates oder eines Beweisstückes sollte jeweils die Integrität verifiziert werden. Dazu wird ein neuer Hash erzeugt (Siehe Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash}). Dies kann entweder manuell oder durch den Einsatz eines Tools oder einer Tool-Suite sichergestellt werden.

\subsubsection{md5sum und md5deep}
Mit diesen beiden Tools wird manuell ein neuer Hash generiert, welcher mit dem dokumentierten Hash des Duplikates oder des Beweisstückes verglichen wird.

\subsubsection{dcfldd}
\todo{Inhalt}

\subsubsection{Weitere Tools} \todo{Inhalt}
EnCase (Seite 72)
Linux: Device Name ermitteln: /proc/partitions oder logs, dann: "`dd if=/dev/<suspect drive> of=/some dir/image name"', "`md5sum /some dir/image name"', "`md5sum /dev/<suspect drive>"'
FreeHelix

FTKImager (Windows)



\subsection{Sicherung der Binärdatei von ausgeführten Prozessen}
Unter Umständen wurde auf dem System ein Prozess gestartet und die dazugehörige Binärdatei anschliessend gelöscht. Der Prozess ist dann solange aktiv, bis das System neu gestartet oder heruntergefahren wird. Solange das System noch läuft kann eine Kopie der Binärdatei um Proc-Dateisystem gefunden werden.

\subsubsection{Linux}
\begin{lstlisting}
> cat /proc/<PDI>/exe > /<OutputPath>
\end{lstlisting}



\subsection{Sicherung flüchtiger Daten}
Die Sicherung von flüchtigen Daten muss effizient, schnell und korrekt erfolgen. Nachfolgend werden die wichtigsten zu sichernden Informationen mit den dazugehörigen Befehlen aufgelistet.

\subsubsection{Linux}
\begin{itemize}
\item Informationen über den Prozessor 
\begin{lstlisting}
cat /proc/cpuinfo
\end{lstlisting}

\item Grösse und Anzahl der eingebundenen Partitionen und deren Füllungsgrad 
\begin{lstlisting}
df -h
\end{lstlisting}

\item  Informationen über den physischen Datengräger und die Partitionierung
\begin{lstlisting}
fdisk -l
\end{lstlisting}

\item  Information über den aktiven Kernel, Compiler-Version und Kommpilierdatum, etc.
\begin{lstlisting}
cat /proc/version
\end{lstlisting}

\item  Anzeige der aktiven Boot-Parameter
\begin{lstlisting}
cat /proc/cmdline
\end{lstlisting}


\item  Anzeige der Shell-Umgebungsvariablen
\begin{lstlisting}
env
\end{lstlisting}

\item  Anzeige der angemeldeten User
\begin{lstlisting}
who
\end{lstlisting}

\item  Liste der alufenden Prozesse
\begin{lstlisting}
ps -efl
\end{lstlisting}

\item  Informationen über die konfigurierten Netzwerk-Interfaces und deren Statistik 
\begin{lstlisting}
ifconfig -a, ifconfig -s
\end{lstlisting}

\item  Anzeige der Einträge der Arp-Table
\begin{lstlisting}
arp -n, arp -n
\end{lstlisting}

\item  Anzeige des Inhalts des Host-File
\begin{lstlisting}
cat /etc/hosts
\end{lstlisting}

\item  Anzeige der DNS-Konfiguration
\begin{lstlisting}
cat /etc/resolv.conf
\end{lstlisting}

\item  Inhalt der Passwortdatei
\begin{lstlisting}
cat /etc/passwd
\end{lstlisting}

\item  Inhalt der Shadow-Datei
\begin{lstlisting}
cat /etc/shadow
\end{lstlisting}

\item  Anzeige der aktiven Netzwerkverbindungen
\begin{lstlisting}
netstat -anp
\end{lstlisting}

\item  Anzeige der Routing-Tabelle
\begin{lstlisting}
netstat -rn
\end{lstlisting}

\item Anzeige der geöffneten und aktiven Ports 
\begin{lstlisting}
lsof -P -i -n
\end{lstlisting}

\item  Komplette Ausgabe aller durch Prozesse geöffneten Dateien
\begin{lstlisting}
lsof
\end{lstlisting}

\item  Informationen über den Hauptspeicher
\begin{lstlisting}
cat /proc/meminfo
\end{lstlisting}

\item  Information über aktive Module
\begin{lstlisting}
cat /proc/modules
\end{lstlisting}

\item  Informationen über die gemounteten Dateisysteme
\begin{lstlisting}
cat /proc/mounts
\end{lstlisting}

\item  Informationen über die Swap-Konfiguration
\begin{lstlisting}
cat /proc/swap
\end{lstlisting}

\item  Konfiguration der Mountpoints
\begin{lstlisting}
cat /etc/fastab
\end{lstlisting}

\item  Pro Prozess: Umgebungsvariablen, verwendete Speicherbereiche, etc.
\begin{lstlisting}
ls /proc | sort -n | grep -v [a-z,A-Z] | while read PID
	do
		echo "`Prozess ID $PID:"`
		cat /proc/$PID/cmdline
		cat /proc/$PID/environ
		cat /proc/$PID/maps
		cat /proc/$PID/stat
		cat /proc/$PID/statm
		cat /proc/$PID/status
		cat /proc/$PID/mem
		ls -ld /proc/$PID/root
		ls -ld /proc/$PID/cwd
		ls -ld /proc/$PID/exe
		ls -lrta /proc/$PID/fd
		echo "`-------------------"'
	done > <OutputPath> 2>&1
\end{lstlisting}
\end{itemize}





%---------------------------------------------------------------------------------------------------------------
\section{Analysis}

\subsection{Image mounten}
Read-Only

Zuerst hashen, dann mounten, dann hashen
\begin{lstlisting}
mount -r -o loop <PathToImage> <MountPoint>
\end{lstlisting}

\subsection{Gelöschte Datenträger}
Datenträger-Löschsoftware, welche wurde eingesetzt? (noch installiert? typische Spuren?) arbeiten nicht immer zufälligen Löschpattern, evtl. Löschsoftware nicht ganz zuverlässig --> Temporäre Dateien, Registry, Protokolle, ...


\subsection{Gelöschte Partitionstabelle}
Hat ein Datenträger den anschein gelöscht worden zu sein, sollte diese in jedem Fall trotzdem untersucht werden. Befinden sich auf dem Datenträger noch Daten kann ein Versuch unternommen werden, das Dateisystem zu rekonstruieren. Im Falle eines ext-Dateisystems muss der Datenträger nach einer bestimmten Signatur (0xef53) durchsucht werden. Diese Signatur kennzeichnet den Superblock des Dateisystems. Ein Backup des Superblocks wird in der Regel zusätzlich an mehreren Stellen des Dateisystems abgelegt. Anhand des Superblockes kann das gesamte Dateisystem rekonstruiert werden.

\subsubsection{Tools}
SMART, findsuper, PartitionMagic


\subsection{Analyse des File Slacks}
Aufgrund der Besonderheiten einiger Dateisysteme können auf Datenträgern mit einem solchen Dateisystem Dateien versteckt werden. Der Grund dafür liegt, darin das eine Datei auf dem Datenträger in sogenannten Dateiblöcken mit einer festen Länge gespeichert werden. Füllt eine Datei nicht den gesamten Dateiblock aus entsteht ein ungenutzter Bereich. Dieser Bereich wird File Slack genannt und wird vom Betriebssystem mit zufälligen Daten aufgefüllt. Unter Windows werden für das Auffüllen des Slacks zum Beispiel Inhalte aus dem Arbeitsspeicher verwendet. Dies wird dann als RAM-Slack bezeichnet.

\todo{Dateisysteme mit FileSlack}

Die File Slack Analyse ermöglicht dem Ermittler unter Umständen auf Inhalte zuzugreifen, welcher der Täter gelöscht hat.

\subsection{Timeline-Analyse}
Bei der Timeline-Analyse werden die letzten Aktivitäten, welche auf dem System durchgeführt wurden, in ein zeitlich logische Abfolge gebracht. Bei der Herstellung einer Verbindung zu anderen Beweisen ist eine allfällige Abweichung der Systemzeit von der Referenzzeit zu beachten. Die Timeline-Analyse ist häufig der erste Ansatzpunkt einer Ermittlung. Durch die Analyse kann festgestellt werden, was undder Täter auf dem System gemacht / verändert / installiert hat. Ausgehend von dem entstehenden Zeitstrahl können weitere, vertiefte Analysen durchgeführt werden. Ein wichtiger Baustein der Timeline-Analyse ist die Auswertung der MAC-Time der Dateien und Ordner. Die MAC-Time setzt sich aus folgenden Elementen zusammen:

\begin{itemize}
\item Modification Time\\
Zeitpunkt der letzten Modifikation (Schreiben), Der Zeitstempel ändert sich bei folgenden Aktionen nicht: Kopieren, Verschieben, Umbenennen, Veränderung Dateiattribute
\item Access-Time\\
Zeitpunkt des letzten Zugriffes (Lesen / Ausführen), Der Zeitstempel wird auch verändert, wenn Metadaten oder Dateiinhalte angezeigt werden
\item Creation-Time (Windows)\\
Zeitpunkt der Erstellung der Datei, Der Zeitstempel wird bei Erstellung einer Kopie aktualisiert. Beim Verschieben einer Datei / Ordner wird der Zeitstempel nicht aktualisiert.
\item Change-Time (Unix)\\
Zeitpunkt der Veränderung bestimmter Metadaten der Datei
\end{itemize}

Nicht jede Aktion löst auf der Datei selbst eine Veränderung der MAC-Time aus. Unter Linux bewirkt die Verschiebung einer Datei eine Veränderung der MAC-Time des Verzeichnises, aber nicht der Datei selbst. Die MAC-Time kann jedoch relativ einfach durch den Angreifer, beziehungsweise durch Anti-Forensik-Tools manipuliert oder unbrauchbar gemacht werden. Eine weitere Schwierigkeit besteht darin, dass die MAC-Time sich je nach Betriebssystem anders verhält.

\subsubsection{Tools}
\textbf{Sleuth Kit}
\begin{enumerate}
\item Dateinformationen sammeln
\begin{lstlisting}
fls -f <Filesystem> -m <Path> -r <MountPoint>/<PathToimage> > body.fls
fls -f linux-ext2 -m / -r /mnt/images/hda7.dd > body.fls
\end{lstlisting}

\item Metadaten sammeln
\begin{lstlisting}
ils -f <Filesystem> -m <MountPoint>/<PathToImage> >> body.fls
ils -f linux-ext2 -m /mnt/images/hda7.dd >>body.fls
\end{lstlisting}

\item Gemeinsame Auswertung
\begin{lstlisting}
mactime -b body.fls
\end{lstlisting}

\end{enumerate}


\subsection{Analyse von Auslagerungsdateien}
Fast alle OS: Erweiterung physisch nutzbarer Speicherbereich, oder Auslagerung kurzfristig nicht benötiger Speicher
Auslagerungs- oder Swap-Dateien, Datei oder virtuelles / physisches Dateisystem
Win: Swap / Page-File: nicht gelöscht bei Shutdown, 

Linux: Swap --> Behandlung wie Binärdateien, kann alles beinhalten
Sonderfälle: Inhalt Hauptspeicher vor Eintritt in Ruheszustand / Suspend-To-Disk-Modus, nach Wake-Up wieder gleich, Hilfreich: RAM-Analyse


\subsection{Analyse von gelöschten Dateien}

\subsubsection{Tools}
\textbf{Sleuth Kit}\\
\begin{enumerate}
\item Identifizierung
\begin{lstlisting}
fls -rd <MountPoint>/<PathToImage.dd>
\end{lstlisting}
\item Dateien wiederherstellen
\begin{lstlisting}
istat <MountPoint>/<PathToImage.dd> <Inode>
icat <MountPoint>/<PathToImage.dd> <Inode> > <OutputPath>
\end{lstlisting}
\end{enumerate}


TASK, 
SMART (Ext2, ext3) Suche in unalloziertem Bereich, Auffindung gelöschte Files

\subsection{Analyse von versteckten Dateien}
Klassische Festplatte:
Section Gaps: Sektoren überall gleich --> am Rand Gaps
Paritions Gaps: Mehrere Partitionen, Gaps --> spuren früherer Partitionen, Daten vestecken, auch in unpartitionierten Bereich

Bad Blocks: Vom OS als unbrauchbar markiert, missbrauch möglich
Hidden-Attribut: Möglichkeit auf OS Ebene Dateien zu verstecken


Rootkits: Können gut Dateien, Verzeichnis, Prozesse, Netzwerkverbindungen verbergen --> trojanisierte Systemprogramme
Kernel-Level-Rootkits: Prozesse, Verbindungen, Dateien verstecken + Hintertüren bereitstellen, Austausch von System-Calls, Aufspüren schwierig: Analyse von Strukturen, Beobachtungen, Vergleich Syscall-tAbelle, z.T. auch Syscall-Code direkt verändert

Bei modernen: Reduktion durch Mapping-Technologien

\subsubsection{Tools}
\textbf{unrm und lazarus} \\
Wiederherstellung unallozierter Bereiche
\begin{lstlisting}
unrm <PathToDisk> > <OutputPath>
lazarus -h <OutputPath>
\end{lstlisting}


\subsection{Dateien oder Fragemente wiederherstellen}
File Carving: Zusammensetzen von Dateifragementen, Extraktion wesentlicher Informationen, Wiederherstellung aus File-Slack oder unalloziertem Bereich, 
Temp-Bereich: gelöschte Reste compilerlauf vom kompilieren von Codes, Wiedeherstellung nur am Duplikat, wenn Live: Auf sparatem System speichern

Anti-Forensik: Mehrfaches überschreiben mit echten zufälligen Bitmustern oder Nullen

\subsubsection{Tools}
\textbf{foremost} \\
\begin{lstlisting}
foremost -v -c <PathToForemostConfig> <PathToImage.dd>
\end{lstlisting}


\textbf{Fatback}\\
FAT-partitionen unter unix untersuchen
\begin{lstlisting}
fatback <PathToImage.dd>
\end{lstlisting}

Weitere: Scalpel, Foregone

\subsection{Unbekannte Binärdateien analysieren}
Fund Binärdateien (z.B. Rootkits, Tools) --> Analyse --> Hinweise / Absichten Täter, Vergleich Prüfsumme (Originaldatei?), Analyse auf Analysesystem --> Ausführung in isolierter Testumgebung

Ablauf gemäss CF: Seite 141

-DAteityp ermitteln (file), Virusscan, 

Tools: PEiD: Analyse Windows-Datei, kann getäuscht werden.
String-Analyse: Suche aller lesbaren Zeichen in Binärdatei --> Hilfetexte, Infos Autor, Copyright
Tools: Unix/Cygwin: strings, BinText, WinHex, IDA Pro

Laufzeitanalyse in isolierter Umgebung (Prozess, netzwerk-, Dateisystemaktivitäten), Analyse Hauptspeicher, Virtuelle Umgebung

Unix: strace, truss --> Zugriff auf welche Ressourcen

Auffinden von nicht angepassten STandard Kits / Tools relativ einfach

weitere Möglichkeit: Analyse dynamisch eingebundener Bibliotheken --> Grundfunktion nachvollziehen
ldd

\subsection{Suche nach Rootkits}
Rootkits, trojanisierte Systemprogramme, ok für Standard-Rootkits

\subsubsection{Tools}
\textbf{chkrootkit}\\
\begin{lstlisting}
chkrootkit
\end{lstlisting}

\subsection{Systemprotokolle}
Anzeichen vor Angriff, oder vom Angrif, wenn nicht gesäubert --> anhaltspunkte, nicht typsich für Post-Mortem, häufig im Betrieb --> Feststellung Angriff

3 Formen: Normale Meldungen (Tagesbetrieb), ANzeichen Angriffe / kritische Meldungen, Unbekannte Meldungen
--> Fehlgeschalgende Anmeldeversuche, Erfolgreiche Anmeldeversiche im Vorfeld von laken Angriffen oder SU-vErsuchen
--Aktionen welche erweiterte Rechte erfoern, Shutdeon / Restor

Details im Kapitel Detection


\subsection{Untersuchung der Shell (Bash)}
MAC-Time der Shell untersuchen, .bash\_profile und .bashrc --> Shell startup commands, evtl. referenziert file /etc/skel directory --> prüfen

.bash\_history: Audit-Trail der Bash
.bash\_logout: commands when exit shell, auch in ordner /Etc/skel evtl. globales script

Oft link history file nach /Dev/null --> Schwarzes Loch

\subsection{Untersuchung der Druckerjobs und der Druckerqueue}
ÄLteres Unix: LPR, /var/log/lpr.log, /var/spool

Neuer: CUPS: /var/log/cups, alternativ: Config Files in /etc/ --> anderer Speicherort, /var/spool/cups

Auffindung gedruckter Dokumente --> Was / Wer, Timeline-Analyse, Beweis für gelöschtes File --> ansatzpunkt bei Suche nach gelöschtem File in Speicher

\subsection{Untersuchung der Dateien / Dateiendungen}
\todo{HECF: S. 172}

\subsection{Untersuchung von User Aktivitäten}

\subsection{Vertiefte Analyse bei Verdacht auf Anti-Forensik-Techniken}

\subsection{Suche nach SUID und GID-Dateien}
Veränderung MAC
\begin{lstlisting}
find / -perm -2000 -o -perm -4000 -print | xargs /ls -l {}
\end{lstlisting}

\subsection{Datei- und Verzeichnisrechte}
Veränderung MAC
\begin{lstlisting}
ls -lrta /etc/
ls -lrta /bin
ls -lrta /sbin
ls -Rlrta /usr
ls -Rlrta /var
ls -Rlrta /dev
ls -Rlrta /home
ls -Rlrta /lib
\end{lstlisting}

\subsection{Weitere Analyse-Möglichkeiten}
\begin{itemize}
\item Analyse der Master File Table
\item Analyse von NTFS-Streams
\item Analyse von NTFS TxF
\item NTFS-Volumen-Schattenkopien
\item Analyse der Windows-Registry
\item Analyse der Windows UserAssist Keys
\item Analyse der Windows Prefetch-Dateien
\item Analyse von Netzwerkmitschnitten
\end{itemize}

%---------------------------------------------------------------------------------------------------------------
\section{Reporting}




%-------------------------------------------
%http://forensicswiki.org/wiki/Tools#Forensics_Live_CDs

\section{Tool-Sammmlungen}
\begin{itemize}
\item F.R.E.D. (First Responder's Evidence Disk)\\
Schnell Statusinformationen von Live-systemen, Prüfsummen, Statische kompiliert, Batch-Datei --> Anpassbar
\item Incident Response Collection Report (IRCR)\\
Windows, Sammlung Werkzeuge zur Sammlung kritischer Systemdaten, Verwendung Systembefehle (nicht spurlos)
\item Windows Forensic Toolchest (WFT)\\
Live-System, Windows, Sammlung, Privat: Kostenfrei, Zerstört im Vergleich wenig Spuren, flexible Anpassungen, Reports
\item Live View\\
Windows, Java-Anwendung, Erstellung einer VM Ware Virtual Machine aus dd Image oder physischem Datenräger, readonly image
\end{itemize}

\section{Tool-Suiten}
\begin{itemize}
\item Encase \\
Windows-Tool, Analyse für Dateisysteme von Windows, Mac OS, Linux, Solaris, AIX, HP UX, ...
Automatisierung mit EnScript, sehr grosse Palette an Tools, breite Auswahl an Untersützten Anwendungen, OS, Mehrsprachig
Enterprise-Version
\item F.I.R.E\\
Free, Toolsammlung
Forensische Analyse / Datenrettung (sleuth Kit, Autopsy Forensic Browser, ...)
Incident Response an Live-systemen
Virusscan
Penetrationstest
Windows, Linux, Solaris
Not maintained anymore,
RAM-Disk
\\item Knoppix Security Tools Distribution\\
Security-Tools, Penetration-Testing, Vulnerability Assemssment, Forensik / Incident-Response-Werkzeuge
Not maintained anymore
\item Helix
Statisch vorkompilierte Dateien für LInux, Solaris, Windows
Free, Enterprise Version: Case Management WErkzeuge, Umfangreiche Supportmöglichkeiten durch hersteller
Windows: Live-Response-Funktionalität, Hoher Integrationsgrad
RAM-Disk
\item ForensiX-CD\\
Windows + Linux, Toolsammlung, statisch vorkompiiert
\item C.A.I.N.E und WinTayloer \\
Live-CD
WinTayler: Windows-Teil, Incident-Response-Sammlung, Nachteil: Basis Visual Basic 6, benötigt entsprechende Bilbiotheken, 
\item DEFT und DEFT-Extra\\
Linux, Windows, Win-Werkzeuge unter linux mit WINE
Windows-Teil: EFT-Etra
Live-Response
\item Forensic Acquisition Utilities \\
Tool-Sammlung, Voraussetzung: Windows 200 oder höher
\item AccessData Forensic Toolkit
Komplette Analyseumgebung für unix- und Windows-Dateisysteme, Mehrbenutzerfähig (via DB-SErver)
\item The Coroner's Toolkit and TCTUtils\\
Post-Mortem Analyse Unix-Systeme, 
\item The Sleuth Kit\\
Sammlung von Tools, diverse Formate
\item Autopsy Forensic Browser\\
Grafische Oberfläche für Sleuth Kit, neuste Version nur Windows
\end{itemize}


Tools: CF: S. 175


\section{Hinweise zu Tooleinsatz}
-Frage des Tools oft anlass für Gundsatzdiskussion Ermittlungsmethoden
Verständnis unterschiedlicher Ansätze der diversen Forensik-Lösungen, 

nicht-kommerzielle Werkzeuge: notwendige Transparenz für Bewertung von Beweissicherungsverfahren
Open Source vs Kommmerziell: klassische ideologische Diskussionen, für juristische Verwendunung beides OK, wenn etabliert

CF erfordert oft Einsatz von Werkzeugen für zuverlässige Sammlung / Asuwertung, Schwierigkeiten beginnen schon bei Sammlung Scripte von Kommandozeilenwerkzeuge vs. GUI basierte Anwendungen

Oft je nach Situation andere Tools notwenidjg, z.bB. Windows Analyse -> Windows System, Linux ext-Dateiystem --> Linux

Üben und auseinandersetzen mit Tools

Absicherung Workstation des Ermittlers, lokal gespeicherte Ergebnisse, Notizen, etc. --> verschlüsseln

Hinweis zu verwendung statisch vorkompilierte Systembefehle

http://www.computer-forensik.org/tools/
\section{Kommerzielle Tools}
-SMART
-Helix (ein Teil Freeware)


\section{Tool-Matrix}
\begin{table}[H]
\centering
\caption{Verfügbarkeit der Tools auf verschiedenen Betriebssystemen}
\begin{tabular}{r | c | c | c | c}
Name 					&	\THrot{Windows}		&	\THrot{Linux}		&	\THrot{Mac OSX}		& 	\THrot{Weitere}		\\
\midrule
Test 					&	x			&				&	x			&			\\	
\bottomrule
\end{tabular}
\end{table}

\section{Technik-Matrix}
\begin{table}[H]
\centering
\caption{Einsatz der Techniken auf verschiedenen Betriebssystemen}
\begin{tabular}{r | c | c | c | c}
Name 					&	\THrot{Windows}		&	\THrot{Linux}		&	\THrot{Mac OSX}		& 	\THrot{Weitere}		\\
\midrule
Test 					&	x			&				&	x			&			\\	
\bottomrule
\end{tabular}
\end{table}

\section{Tool-Technik-Matrix}
Nur Tool-Suiten

\begin{table}[H]
\centering
\caption{Tools: Unterstützte Techniken}
\begin{tabular}{r | c | c | c | c}
Name 					&	\THrot{Tool1}		&	\THrot{Tool2}		&	\THrot{Tool3}		& 	\THrot{Tool4}		\\
\midrule
Test 					&	x			&				&	x			&			\\	
\bottomrule
\end{tabular}
\end{table}

