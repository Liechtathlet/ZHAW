\chapter{Tools und Techniken} \label{chap:ToolsTechniques}
In diesem Kapitel werden die grundlegenden Tools und Techniken einer forensischen Analyse unter Linux vorgestellt. Die Tools und Techniken werden dabei nach der Phase, in der diese eingesetzt und angewendet werden, gegliedert.




%---------------------------------------------------------------------------------------------------------------
\section{Readiness}
In diesem Kapitel werden einige Techniken und Tools aufgezeigt, welche während der Phase "`Readiness"' von Bedeutung sind.


\subsection{Datenträger löschen}
Digitale Beweise und Kopien von Images sollten immer auf leere, beziehungsweise zuvor komplett gelöschte Datenträger gesichert werden. Wird dies nicht gemacht, kann es sein, dass Rückstände / Daten von vorherigen Untersuchungen die Analyse beeinflussen.

\subsubsection{dd}
Unter Linux kann für das Löschen, genauer gesagt das Überschreiben mit Zufallswerten (1) oder Nullen (2) das Tool \textit{dd} verwendet werden.
Mit dem Tool \textit{dd} können sowohl ganze Datenträger, als auch einzelne Partitionen überschrieben werden.

\begin{lstlisting}
> dd if=/dev/urandom of=/dev/<DriveToWipe>
> dd if=/dev/zero of=/dev/<DriveToWipe>
\end{lstlisting}

\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item EnCase
\item FTK
\item X-Ways
\end{itemize}




%---------------------------------------------------------------------------------------------------------------
\section{Secure}
In diesem Kapitel werden einige Techniken und Tools aufgezeigt, welche während der Phase "`Secure"' von Bedeutung sind. 


\subsection{Auslesen der Zeitkonfiguration}
Die Zeitkonfiguration des Systemes wird je nach Betriebssystem und zum Teil sogar je nach Distribution an einem anderen Ort gespeichert.

Unter Ubuntu, beziehungsweise Debian-Systemen ist diese unter \textit{/etc/timezone} zu finden. Bei Red-Hat-Distributionen unter \textit{/etc/sysconfig/clock}.
Beim Auslesen der Zeitkonfiguration ist auch zu notieren, ob das System automatisch zwischen Sommer- und Winterzeit umstellt.

\begin{lstlisting}
> cat /etc/timezone
Europe/Zurich
\end{lstlisting}

Das Datum und die Uhrzeit kann über nachfolgenden Befehl ausgelesen werden. Zu beachten ist hier, dass eine statisch vorkompilierte Version des Befehsl verwendet wird.
\begin{lstlisting}
> date
Fre Mai 29 08:00:00 CEST 2015
\end{lstlisting}


\subsection{Bestimmung der Linux-Distribution}
Jede Linux-Distribution hat ihre Eigenheiten. Dazu zählen unter anderem Befehle, Speicherorte, Methoden für Tracking und Auditierung der User Aktivität und das Logging von System Events.

Unter vielen Distributionen befindet sich unterhalb des Ordners \textit{/etc} ein File, welches die Versions-Informationen enthält.\\
\begin{lstlisting}
> ls /etc | grep -E "`release|version"'
debian_version
lsb-release
lsb-release.dpkg-dist
os-release
upstream-release

> cat /etc/debian_version
jessie/sid

> cat /etc/os-release
NAME="Ubuntu"
VERSION="14.04.2 LTS, Trusty Tahr"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 14.04.2 LTS"
VERSION_ID="14.04"
HOME_URL="http://www.ubuntu.com/"
SUPPORT_URL="http://help.ubuntu.com/"
BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"
\end{lstlisting}

Ist kein entsprechendes File vorhanden kann das Logon-Banner oder die Log-Einträge unter \textit{/var/log/dmesg} oder \textit{/var/log/messages} allenfalls Hinweise zur Distribution enthalten:\\
\begin{lstlisting}
> cat /etc/issue
Linux Mint 17 Qiana \n \l

> cat /var/log/dmesg
[    0.000000] Initializing cgroup subsys cpuset
[    0.000000] Initializing cgroup subsys cpu
[    0.000000] Initializing cgroup subsys cpuacct
[    0.000000] Linux version 3.13.0-49-generic (buildd@akateko) (gcc version 4.8.2 (Ubuntu 4.8.2-19ubuntu1) ) #83-Ubuntu SMP Fri Apr 10 08:00:00 UTC 2015 (Ubuntu 3.13.0-49.83-generic 3.13.11-ckt17)
[    0.000000] Command line: BOOT_IMAGE=/boot/vmlinuz-3.13.0-49-generic root=UUID=ee905b77-1264-477b-9942-23bd448df95c ro quiet splash acpi_backlight=vendor acpi_osi=Linux vt.handoff=7
[    0.000000] KERNEL supported cpus:
[    0.000000]   Intel GenuineIntel
[    0.000000]   AMD AuthenticAMD
[    0.000000]   Centaur CentaurHauls
[    0.000000] e820: BIOS-provided physical RAM map:
\end{lstlisting}

Oft gibt auch der verwendete Package-Manager ein Hinweis auf die verwendete Distribution:
\begin{itemize}
\item Ubuntu Linux: APT, Synaptic
\item Red Hat / Fedora Linux: RPM
\item Gentoo Linux: Portage / Emerge
\item SUSE Linux: YaST
\item Debian Linux: APT
\end{itemize}



\subsection{Shutdown eines Systemes}
Ein laufendes System kann grundsätzlich auf zwei verschiedene Arten heruntergefahren werden. Zum einen kann ein normaler, regulärer Shutdown des Systemes durchgeführt werden. Dabei werden sämtliche Datei gespeichert und temporäre Daten gelöscht / aufgeräumt. Das System befindet sich anschliessend in einem sauberen / lauffähigen Zustand. Während dem Shutdown werden jedoch bei zahlreichen Dateien die Zeitstempel verändert und sämtliche Daten welche sich im Arbeitsspeicher befinden gehen verloren. Dies kann unter Umständen die Analysearbeiten erschweren oder im schlimmsten Fall wichtige Beweise vernichten.

Die andere Methode ein System herunterzufahren ist der harte Shutdown. Beim harten Shutdown wird das System von der Stromversorgung getrennt, ohne das dieses vorher heruntergefahren wurde. Mit diesem Vorgehen wird sichergestellt, dass die Zeitstempel unverändert bleiben und die temporären Daten erhalten bleiben. Auch ist die Wahrscheinlichkeit da, dass auf der Festplatte eine Auslagerungsdatei vorhanden ist, welche analysiert werden kann. Die Extraktion und Analyse dieser Daten ist jedoch sehr aufwändig. Diese Methode des Shutdowns kann bei gewissen Dateisystemen zu irreparablen Schäden führen. Daher ist vorgängig abzuwägen, ob ein harter Shutdown sinnvoll und verkraftbar ist.

Bei beiden Varianten ist die Zeit der Durchführung und die Art des Shutdowns zu protokollieren.

Die Möglichkeiten den Inhalt des Arbeitsspeichers zu sichern, werden im nachfolgenden Kapitel vorgestellt.



\subsection{Erstellen von Hashes} \label{subsec:ToolsTechniques:Secure:Hash}
Für die Sicherung von Daten ist die Erstellung von Hashes von essentieller Bedeutung. Jede Datei, Partition oder ähnlich sollte vor und nach der Sicherung gehasht werden, um sicherzustellen, dass diese durch den Sicherungsvorgang nicht verändert wurde. Auch Protokolle, Dokumentation, Ergebnisse der Analyse, etc. sollten immer mit einem Hash versehen und geprüft werden.

\subsubsection{md5sum}
Mit folgendem Befehl können MD5-Hashes von einzelnen Dateien erstellt werden. Es stehen unter anderm MD2, MD4, MD5, SHA und SHA1 als Algorithmen zur Verfügung. Der Befehl entspricht jeweils dem Algorithmus. Zum Beispiel für SHA1 wird der Befehl \textit{sha1sum} verwendet.

\begin{lstlisting}
> md5sum <FileName>
\end{lstlisting}

\subsubsection{md5deep}
Mit dem Tool "`md5deppe"' können Hashes von Ordnerinhalten rekursiv erstellt werden. Es können dabei Hashes mit dem MD5, dem SHA1, dem SHA256, dem Tiger und Whirlpool Algorithmus erstellt werden.

\begin{lstlisting}
> md5depp -r <PathToDirectory>
\end{lstlisting}



\subsection{Sicherung des Arbeitsspeicher-Inhaltes}
Bei der Sicherung von Arbeitsspeicher-Inhalten ist grundsätzlich zu beachten, dass die verwendeten Tools und Techniken einen kleinen Memory-Footprint aufweisen. Je mehr Arbeitsspeicher ein Tool verwendet, desto mehr wichtige Daten und somit auch Beweise gehen verloren. Ein weiterer wichtiger Punkt der beachtet werden soll ist, dass die Sicherung nicht im User-Mode, sondern im Kernel-Mode erfolgt. So ist sichergestellt, dass der gesamte Inhalte des Arbeitsspeichers gesichert werden kann. Andernfalls können aufgrund von Berechtigungseinschränkungen nicht alle Daten gesichert werden.

\subsection{Sicherung des Arbeitsspeicher-Inhaltes ohne Zugriff auf das Betriebssystem}
Grundsätzlich gilt, dass der Inhalt des Arbeitsspeichers beim herunterfahren des Systems verloren geht. Besteht kein Zugriff auf das Betriebssystem und es besteht keine Möglichkeit das Passwort zu erhalten, muss gegbenenfalles eine der nachfolgend beschriebenen Techniken eingesetzt werden. Studien haben gezeigt, dass die Inhalte des Arbeitsspeichers noch bis zu mehreren Minuten nach dem Verlust der Stromversorgung im Arbeitsspeicher vorhanden sind. Bei einigen BIOS-Varianten wird der Arbeitsspeicher beim Herunterfahren des Systemes vollständig gelöscht. Bei diesen Systemen ist ein Auslesen nach dem Herunterfahren nicht mehr möglich.

\begin{itemize}
\item Cold Boot\\
Nach dem harten Shutdown des Systemes wird ein speziell präpariertes USB-Boot-Medium eingesetzt und das System sofort neu gestartet. Dabei ist im BIOS die Bootreihenfolge so zu ändern, dass das USB-Medium als primäres Boot-Medium verwendet wird. Das USB-Medium wurde vorgängig mit einem Minibetriebssystem, einem Spezialtool und einer separaten Partition zur Speicherung des Arbeitsspeicher-Abbildes. Als Tool zur Sicherung kann entweder \textit{Msramdmp} oder der \textit{USB Memory Scraper} verwendet werden.

\item Cold Boot mit Kühlung des physikalischen Bausteins\\
Bevor das System mit einem harten Shutdown heruntergefahren wird, wird das Gehäuse des Systems geöffnet und der Arbeitsspeicher mit einem Stickstoffspray auf -50 Grad Celsius herunter gekühlt. Dadurch werden die physikalischen Prozesse verlangsamt und die Daten bleiben im physischen Baustein länger erhalten. Nach dem harten Shutdown wird der Arbeitsspeicher ausgebaut und in einem Analyse-System  eingebaut. Das Analyse-System wird mit einer Spezialsoftware gestartet, welche den gesamten Arbeitsspeicher auf einen anderen Datenträger sichert.

\item Firewire-Attacke\\
Bei der Firewire-Attacke wird eine Schwachstelle der Firewire-Schnittstelle ausgenutzt, um Inhalte des Arbeitsspeichers zu sichern. Die Schwachstelle kann jedoch nur unter bestimmten Bedingungen ausgenutzt werden und es kann nur eine begrenzte Menge (aktuell max. 4 GB) an Arbeitsspeicher ausgelesen werden. Als unterstützendes Tool zur Realisierung dieses Angriffes sei an dieser Stelle das Tool \textit{PythonRaw1394} genannt. Weitere Informationen zur Firewire-Attacke sind hier zu finden: \url{https://blogs.gnome.org/muelli/2010/04/reading-ram-using-firewire/}, \url{http://link.springer.com/chapter/10.1007%2F978-3-642-23602-0_14#page-1}
\end{itemize}

\subsection{Sicherung des Arbeitsspeicher-Inhaltes mit Zugriff auf das Betriebssystem}
Für die Sicherung gibt es einige verschiedene Tools. Unter früheren Linux-Kerneles konnte direkt auf das Arbeitsspeicher-Device zugegriffen werden. In neuer Versionen wurde dies aus Sicherheitsgründen unterbunden.

\subsubsection{Linux (alte Kernel-Versionen)}
\begin{lstlisting}
> dd if=/dev/mem of=ram.dd
\end{lstlisting}

\subsubsection{fmem}
Nachdem \textit{fmem} (vorgängig) kompiliert wurde, muss das Kernel-Modul zuerst geladen werden. Dazu wird am besten das mitgelieferte Shell-Script \textit{run.sh} verwendet werden. Nach dem das Kernel-Modul geladen wurde, steht unter \textit{/dev/fmem} ein neues Device zur Verfügung. Dieses Device kann mit den im Kapitel \ref{subsec:ToolsTechniques:ForensicDuplicate} \nameref{subsec:ToolsTechniques:ForensicDuplicate} beschriebenen Tools gesichert werden.

\subsubsection{lime}
Das Tool \textit{lime} ist ein weiteres Kernel-Modul, welches für die Akquisition von Arbeitsspeicher-Inhalten unter Linux und Linux-basierten Systemen verwendet werden kann.

\begin{lstlisting}
> insmod <PathToLime>/lime.ko "path=<PathToDumpFile> format=<raw|padded|lime>"
\end{lstlisting}

\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item Win32dd und Win64dd
\item DumpIt
\item Winen und Winen64
\item Mdd
\item FTK Imager
\end{itemize}

\subsection{Forensische Duplikation} \label{subsec:ToolsTechniques:ForensicDuplicate}
Bei einer forensischen Duplikation sollte der Quelldatenträger immer Bit-Weise kopiert werden. Zusätzlich ist sicherzustellen, dass der Quelldatenträger Read-Only gemountet oder über einen Writeblocker angeschlossen ist. Ein Writeblocker verhindert physisch, dass Daten auf einen Datenträger geschrieben werden können. Es ist zu empfehlen grundsätzlich immer einen Writeblocker auf Hardware-Basis zu verwenden.

Die Sicherung kann auf folgende Arten durchgeführt werden:
\begin{itemize}
\item Auf einem Live-System\\
Die Duplikation des Datenträgers erfolgt unter Einsatz eines Software-Writeblockers auf dem Live-System
\item Auf dem zu untersuchenden System\\
Die Duplikation erfolgt über eine Live-CD, nachdem das System heruntergefahren wurde. Für die Duplikation wird ein Writeblocker auf Software- oder Hardware-Basis eingesetzt.
\item Auf dem Analyse-System\\
Die Duplikation erfolgt auf dem Analyse-System. Für die Duplikation wird ein Writeblocker auf Software- oder Hardware-Basis eingesetzt.
\item Hardware-Imager\\
Die Duplikation erfolgt durch ein auf Imaging spezialisierte externe Hardware.
\end{itemize}

Das Image des Quelldatenträgers kann entweder auf einem separaten, sterilen Datenträger oder über ein Netzwerk auf einen Server gesichert werden. Bei der Duplikation ist sicherzustellen, dass auch versteckte Bereiche des Datenträgers, wie Host Protected Areas, Device configuration Overlays gesichert werden.

\subsubsection{Einsatz von Standard-Linux Tools}

\begin{enumerate}
\item Mounten des Zieldatenträgers
\begin{lstlisting}
> mount -t <Dateisystem> <PathToDisk> <MountPoint>
\end{lstlisting}

\item Sicherung der Partitionstabelle
\begin{lstlisting}
> fdisk -l <PathToDisk> > <MountPoint>/<FileName.fdisk>

> parted -l <PathToDisk> > <MountPoint>/<FileName.fdisk>
\end{lstlisting}

\item Generierung eines Hashes\\
Vor der Duplikation wird ein Hash des zu sichernden Datenträgers / Partition gemäss Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash} erstellt und dokumentiert.

\item Duplikation
\begin{lstlisting}
> dd conv=noerror bs=512k if=<PathToDisk> of=<MountPoint>/<FileName.dd>
\end{lstlisting}

\item Generierung eines Hashes\\
Nach der Duplikation wird ein Hash des zu sichernden Datenträgers / Partition gemäss Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash} erstellt und mit dem dokumentierten Hash verglichen. Dies stellt sicher, dass der Datenträger während der Duplikation nicht unbemerkt verändert wurde. Anschliessend ist vom erstellten Image ebenfalls ein Hash zu erstellten, welcher mit dem dokumentierten verglichen werden muss. Ist dieser mit dem dokumentierten Hash identisch, wurde der Datenträger / die Partition korrekt dupliziert.

Im Anschluss muss das Verfahren für jede verfügbare Partition wiederholt werden.

\item Transfer des Images via Netzwerk
\begin{lstlisting}
> nc -l -p 8000 |dd of=<MountPoint>/<PathToImage>
\end{lstlisting}

\item Transfer des Images via Netzwerk (Verschlüsselt)
\begin{lstlisting}
> cryptcat -k <Pssword> -l -p 8000 |dd of=<MountPoint>/<PathToImage>
\end{lstlisting}

\end{enumerate}


\subsubsection{dcfldd}
Das Tool \textit{dcfldd} erweitert das Tool \textit{dd} um einige nützliche Funktionen. So können automatisch Hashes für den zu sichernden Datenträger oder die zu sichernde Partition generiert.

\begin{lstlisting}
> dcfldd if=<PathToDisk> of=<MountPoint>/<FileName.dd> hash=sha256 sha256log=<FileName.sha256> bs=1MB count=1000
\end{lstlisting}


\subsubsection{dc3dd}
Das Tool \textit{dc3dd} ist ein Erweiterung, beziehungsweise eine gepatchte Version des Tools \textit{dd}.

\begin{lstlisting}
> dc3dd if=<PathToDisk> of=<MountPoint>/<FileName.dd> hash=md5 progress=on
\end{lstlisting}


\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item Adepto
\item Guymager
\item ewfacquire
\item Raptor Toolbox
\end{itemize}




\subsection{Verifikation eines forensischen Duplikates oder eines Beweisstückes}
Vor und nach der Verwendung eines forensischen Duplikates oder eines Beweisstückes sollte jeweils die Integrität verifiziert werden. Dazu wird ein neuer Hash erzeugt (Siehe Kapitel \ref{subsec:ToolsTechniques:Secure:Hash} \nameref{subsec:ToolsTechniques:Secure:Hash}). Dies kann entweder manuell oder durch den Einsatz eines Tools oder einer Tool-Suite sichergestellt werden.

\subsubsection{md5sum und md5deep}
Mit diesen beiden Tools wird manuell ein neuer Hash generiert, welcher mit dem dokumentierten Hash des Duplikates oder des Beweisstückes verglichen wird.

\subsubsection{dcfldd}
Mit \textit{tcfldd} kann geprüft werden, ob der Hash eines Quelldatenträgers und eines bereits erstellten Images identisch sind.

\begin{lstlisting}
> dcfldd if=<PathToSourceDevice> vf=<PathToImage.dd> verifylog=<PathToLog.log>
\end{lstlisting}

\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:

\begin{itemize}
\item EnCase
\item FreeHelix
\item FTKImager
\end{itemize}


\subsection{Sicherung der Binärdatei von ausgeführten Prozessen}
Unter Umständen wurde auf dem System ein Prozess gestartet und die dazugehörige Binärdatei anschliessend gelöscht. Der Prozess ist dann solange aktiv, bis das System neu gestartet oder heruntergefahren wird. Solange das System noch läuft kann eine Kopie der Binärdatei um Proc-Dateisystem gefunden werden.

\subsubsection{Linux}
\begin{lstlisting}
> cat /proc/<PDI>/exe > /<OutputPath>
\end{lstlisting}



\subsection{Sicherung flüchtiger Daten}
Die Sicherung von flüchtigen Daten muss effizient, schnell und korrekt erfolgen. Nachfolgend werden die wichtigsten zu sichernden Informationen mit den dazugehörigen Befehlen aufgelistet.

\subsubsection{Linux}
\begin{itemize}
\item Informationen über den Prozessor 
\begin{lstlisting}
> cat /proc/cpuinfo
\end{lstlisting}

\item Grösse und Anzahl der eingebundenen Partitionen und deren Füllungsgrad 
\begin{lstlisting}
> df -h
\end{lstlisting}

\item  Informationen über den physischen Datengräger und die Partitionierung
\begin{lstlisting}
> fdisk -lu <PathToHarddisk>
> mmls <PathToHarddisk> (The Sleuth Kit)
> mmls -o <StartSector> <PathToBSDHarddiskSlice> (The Sleuth Kit, FreeBSD)
\end{lstlisting}

\item  Information über den aktiven Kernel, Compiler-Version und Kommpilierdatum, etc.
\begin{lstlisting}
> cat /proc/version
\end{lstlisting}

\item  Anzeige der aktiven Boot-Parameter
\begin{lstlisting}
> cat /proc/cmdline
\end{lstlisting}


\item  Anzeige der Shell-Umgebungsvariablen
\begin{lstlisting}
> env
\end{lstlisting}

\item  Anzeige der angemeldeten User
\begin{lstlisting}
> who
\end{lstlisting}

\item  Liste der ablaufenden Prozesse
\begin{lstlisting}
> ps -efl
\end{lstlisting}

\item  Informationen über die konfigurierten Netzwerk-Interfaces und deren Statistik 
\begin{lstlisting}
> ifconfig -a, ifconfig -s
\end{lstlisting}

\item  Anzeige der Einträge der Arp-Table
\begin{lstlisting}
> arp -n
\end{lstlisting}

\item  Anzeige des Inhalts des Host-File
\begin{lstlisting}
> cat /etc/hosts
\end{lstlisting}

\item  Anzeige der DNS-Konfiguration
\begin{lstlisting}
> cat /etc/resolv.conf
\end{lstlisting}

\item  Inhalt der Passwortdatei
\begin{lstlisting}
> cat /etc/passwd
\end{lstlisting}

\item  Inhalt der Shadow-Datei
\begin{lstlisting}
> cat /etc/shadow
\end{lstlisting}

\item  Anzeige der aktiven Netzwerkverbindungen
\begin{lstlisting}
> netstat -anp
\end{lstlisting}

\item Anzeige der aktiven Netzwerkverbindungen und der dazugehörigen Programmej
\begin{lstlisting}
> netstat -tunp
\end{lstlisting}

\item  Anzeige der Routing-Tabelle
\begin{lstlisting}
> netstat -rn
> route
\end{lstlisting}

\item Anzeige der geöffneten und aktiven Ports 
\begin{lstlisting}
> lsof -P -i -n
\end{lstlisting}

\item  Komplette Ausgabe aller durch Prozesse geöffneten Dateien
\begin{lstlisting}
> lsof
\end{lstlisting}

\item  Informationen über den Hauptspeicher
\begin{lstlisting}
> cat /proc/meminfo
\end{lstlisting}

\item  Information über aktive Module
\begin{lstlisting}
> cat /proc/modules
\end{lstlisting}

\item  Informationen über die gemounteten Dateisysteme
\begin{lstlisting}
> cat /proc/mounts
\end{lstlisting}

\item  Informationen über die Swap-Konfiguration
\begin{lstlisting}
> cat /proc/swap
\end{lstlisting}

\item  Konfiguration der Mountpoints
\begin{lstlisting}
> cat /etc/fastab
\end{lstlisting}

\item Geöffnete Dateisysteme
\begin{lstlisting}
> mount -v
\end{lstlisting}

\item Installierte Software (via Packet-Manager installiert)
\begin{lstlisting}
> dpkg -l
> rpm -qa
\end{lstlisting}

\item Installierte Software (manuell installiert, Eintrag im \textit{\$PATH})
\begin{lstlisting}
> echo $PATH
> whereis <NameOfProgram>
> which <NameOfProgram>
> locate <NameOfProgram>
\end{lstlisting}


\item  Pro Prozess: Umgebungsvariablen, verwendete Speicherbereiche, etc.
\begin{lstlisting}
> ls /proc | sort -n | grep -v [a-z,A-Z] | while read PID
	do
		echo "`Prozess ID $PID:"`
		cat /proc/$PID/cmdline
		cat /proc/$PID/environ
		cat /proc/$PID/maps
		cat /proc/$PID/stat
		cat /proc/$PID/statm
		cat /proc/$PID/status
		cat /proc/$PID/mem
		ls -ld /proc/$PID/root
		ls -ld /proc/$PID/cwd
		ls -ld /proc/$PID/exe
		ls -lrta /proc/$PID/fd
		echo "`-------------------"'
	done > <OutputPath> 2>&1
\end{lstlisting}
\end{itemize}





%---------------------------------------------------------------------------------------------------------------
\section{Analysis}
In diesem Kapitel werden einige Techniken und Tools aufgezeigt, welche während der Phase "`Analysis"' von Bedeutung sind. 



\subsection{Image mounten}
Ein forensisches Duplikat, beziehungsweise ein Image, sollte immer Read-Only gemountet werden. Um sicherzustellen, dass das Image nicht verändert wird, sollte vor und nach dem Mounten jeweils ein Hash des Images erzeugt werden.

\subsection{Linux (dd)}
\begin{lstlisting}
> mount -r -o loop <PathToImage> <MountPoint>
\end{lstlisting}

\subsection{ewfmount}
\begin{lstlisting}
> ewfmount /<PathToImage>.E01 <MountPoint>
\end{lstlisting}

\subsection{xmount}
\begin{lstlisting}
> xmount -in <InFormat> --out <OutFormat> <PathToImage> <MountPointForConvertedImage>
> mount -o ro <MountPointForConvertedImage> <MountPoint>
\end{lstlisting}

\subsection{Gelöschte Datenträger}
Ist ein gesicherter Datenträger leer, beziehungsweise hat den Anschein, als wäre dieser leer, könnte eine Löschsoftware zur Verwischung von Spuren eingesetzt worden sein. Ist dies der Fall sollte zuerst versucht werden herauszufinden, welche Löschsoftware eingesetzt wurde. Allenfalls wurden dazu Hinweise oder Spuren auf anderen Datenträgern hinterlassen. Gewisse Produkte arbeiten beim Löschen nicht mit reinen Zufallswerten, sondern verwenden Löschpattern. Dies kann einen weiteren Hinweis auf die verwendete Löschsoftware liefern. Oft arbeiten auch die Produkte nicht zuverlässig, und es bleiben gewisse temporäre Dateien, Registry-Einträge oder Protokolle übrig, welche für eine Analyse herangezogen werden können. Wurde der Datenträger mehrfach mit echten zufälligen Bitmustern oder Nullen überschrieben, besteht in der Regel praktisch keine Möglichkeit zur Datenwiederherstellung.


	
\subsection{Gelöschte Partitionstabelle}
Hat ein Datenträger den Anschein gelöscht worden zu sein, sollte diese in jedem Fall trotzdem untersucht werden. Befinden sich auf dem Datenträger noch Daten kann ein Versuch unternommen werden, das Dateisystem zu rekonstruieren. Im Falle eines ext-Dateisystems muss der Datenträger nach einer bestimmten Signatur (0xef53) durchsucht werden. Diese Signatur kennzeichnet den Superblock des Dateisystems. Ein Backup dieses Superblocks wird in der Regel redundant an mehreren Stellen des Dateisystems abgelegt. Der Superblock ermöglicht die Rekonstruktion des ganzen oder eines grossen Teiles des Dateisystems.

\subsubsection{Tools} 
Die nachfolgenden Tools bieten gewisse Funktionalitäten, um gelöschte Partitionstabellen zu rekonstruieren.

\begin{itemize}
\item SMART
\item findsuper
\item PartitionMagic
\end{itemize}


\subsection{Analyse von gelöschten Dateien}
Wurden Dateien vom Dateien vom System gelöscht besteht ein gewisse Wahrscheinlichkeit, dass diese mit einem entsprechenden Tool wiederhergestellt werden können.

\subsubsection{Sleuth Kit}
Die Wiederherstellung von gelöschten Daten mit Hilfe der Tools aus dem Sleuth Kit erfolgt nach folgendem Ablauf:
 
\begin{enumerate}
\item Identifizierung von gelöschten Daten
\begin{lstlisting}
> fls -rd <MountPoint>/<PathToImage.dd>
\end{lstlisting}
\item Wiederherstellung ausgewählter Dateien
\begin{lstlisting}
> istat <MountPoint>/<PathToImage.dd> <Inode>
> icat <MountPoint>/<PathToImage.dd> <Inode> > <OutputPath>
\end{lstlisting}
\end{enumerate}

\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item TASK
\item SMART (für Ext2 und Ext3)
\end{itemize}


\subsection{Analyse von versteckten Dateien}
Auf einer Festplatte können an einigen Stellen Daten versteckt werden. Aufgrund des Aufbaus und der Aufteilung einer Festplatte in Sektoren fester Grösse über die gesamte Fläche, können am Rand Abstände zwischen den Sektoren entstehen. In diesen sogenannten Gaps können Daten versteckt werden. Eine weitere Möglichkeit Daten zu verstekcen sind die Partition-Gaps (Abstände zwischen Partitionen) und unpartitionierte Bereiche der Festplatte. Eine etwas andere Methode ist die Verwendung von Blöcken, welche vom Betriebssystem als unbrauchbar markiert wurden (Bad Blocks).  Die einfachste Art um Dateien zu verstecken, ist die Verwendung des Hidden-Attributes des Betriebssystems. Dieses existiert in der einen oder anderen Form in den meisten gängigen Betriebssystemen.

Auch mit Hilfe von Rootkits lassen sich Dateien und Verzeichnisse verstecken. Darüber hinaus können unter anderem auch Prozesse und Netzwerkverbindungen verborgen werden. Normale Rootkits verwenden dafür trojanisierte (manipulierte) Systemprogramme, welche die entsprechenden Dateien, Verzeichnise, etc. herausfiltern. kernel-Level-Rootkits verwenden keine trojanisierten Systemprogramme, sondern manipulieren die Syscall-Tabelle. Einige Kernel-Level-Rootkits verändern sogar direkt den Syscall-Code. Diese Art von Rootkits sind auf dem System sehr schwer aufzuspüren. Um diese zu finden, müssen die Strukturen analysiert, das System beobachtet und mit einem Referenz-System verglichen werden.



\subsection{Dateien oder Fragemente wiederherstellen}
Wurden Dateien auf einem System gelöscht, bleiben möglicherweise gewisse Dateifragmente über längere Zeit erhalten. Können die einzelnen Fragmente im File-Slack oder unallozierten Bereich gefunden werden, können diese zusammengesetzt werden. Der Prozess der Suche und Wiederherstellung von Dateien oder Dateifragementen wird auch als File Carving bezeichnet.

\subsubsection{foremost}
Foremost ist ein File-Carving-Tool welches speziell für Unix entwickelt wurde. Die Widerherstellung erfolgt aufgrund der Analyse von Header- und Footer-Informationen.

\begin{lstlisting}
> foremost -v -c <PathToForemostConfig> <PathToImage.dd>
\end{lstlisting}


\subsubsection{Fatback}
File-Carving-Tool um FAT-Dateisysteme unter Unix zu untersuchen.

\begin{lstlisting}
> fatback <PathToImage.dd>
\end{lstlisting}


\subsubsection{unrm und lazarus}
Mit den Tools unrm und lazarus können Dateien aus dem unallozierten Bereich der Festplatte wiederhergestellt werden. Bei diesem Vorgang fällt eine sehr grosse Menge an Rohdaten an, es sollte daher entsprechend Speicherplatz zur Verfügung stehen.
\begin{lstlisting}
> unrm <PathToDisk> > <OutputPath>
> lazarus -h <OutputPath>
\end{lstlisting}


\subsubsection{Weitere Tools} 
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item Scalpel
\item Foregone
\end{itemize}

\subsection{Entpacken von Dateien}
Dateien können auf einem System in Archiven verpackt werden. Wird bei einer Analyse ein File gesucht, welches sich in einem Archiv befindet, kann dies nicht gefunden werden. Daher sollte man in Erwägung ziehen, die Archive zu Beginn einer Analyse zu entpacken. Dabei können jedoch sehr grosse, zusätzliche Datenmengen anfallen.

\subsubsection{Linux} 
\begin{lstlisting}
> find <PathToImage> -iname "*.tar.gz" -exec tar xvzf {} -C <OutputPath> \;
> find <PathToImage> -iname "*.zip" -exec unzip {} -d <OutputPath> \;
\end{lstlisting}

\subsubsection{7-Zip}
Mit 7-Zip können weitere Archivtypen entpackt werden.

\begin{lstlisting}
> find <PathToImage> -iname "*.rar" -exec 7z e {} -C <OutputPath> \;
\end{lstlisting}

\subsection{Suche nach Dateien / Filterung von Dateien}
Muss auf einem System eine bestimmte Datei gefunden werden oder sollen als ungefährlich eingestufte Dateien aus der Gesamtheit der zu analysierenden Daten herausfiltriert werden, kann dies über Hash-Listen gemacht werden.

Für den ersten Fall wird für jede gesuchte Datei ein Hash erzeugt und in einer Datei abgelegt. Die zu suchende Datei muss zwingend bis auf das letzte Bit identisch mit der zu suchenden Datei sein. Andernfalls kann diese nicht gefunden werden. Für solche Fälle könnte die Datei-Blockweise gehasht und anschliessend nach diesen Teil-Hashes gesucht werden.

\subsubsection{Linux}
\begin{lstlisting}
> find . -type f -print0 | xargs -o md5sum > <PathToHashlist>
> find <PathToFilesToSearch> -type f -print0 | xargs -o md5sum | awk '{
print $1}' > <PathToHashesOfFilesToSearch>
> grep -f <PathToHashlist> <PathToHashesOfFilesToSearch>
\end{lstlisting}


\subsection{Analyse des File Slacks}
Aufgrund der Besonderheiten einiger Dateisysteme können auf Datenträgern mit einem solchen Dateisystem Dateien versteckt werden. Der Grund dafür liegt, darin das eine Datei auf dem Datenträger in sogenannten Dateiblöcken mit einer festen Länge (Sektoren) gespeichert werden. Die kleinste beschreibbare Einheit besteht dabei aus einer Gruppe (typischerweise 8) von Sektoren. Eine solcher Gruppe von Sektoren wird als Cluster bezeichnet. Füllt eine Datei nicht den gesamten Dateiblock aus entsteht ein ungenutzter Bereich. Dieser Bereich wird File Slack genannt und wird vom Betriebssystem mit zufälligen Daten aufgefüllt. Dieser Slack unterteilt sich zum einen in RAM-Slack, welcher früher unter Windows mit Inhalten aus dem Arbeitsspeicher aufgefüllt wurde (heute mit Nullen), und zum anderen in Drive-Slack. Der RAM-Slack erstreckt sich vom letzten Byte der Datei bis zur nächsten Sektorgrenze. Der Drive-Slack (auch Sektor- oder Cluster-Slack genannt) ist der restliche Bereich zwischen dem Ende des RAM-Slacks und der Cluster-Grenze.

Im Drive-Slack können sicht unter Umständen wertvolle Informationen für die weitere Analyse befinden. Wichtig zu wissen ist hier, das ein Beweis eindeutig einer Person zugeordnet werdene können muss. Dies ist beim Drive-Slack nicht der Fall.

Neben dem File-Slack gibt es auf einem Computer-System noch weitere Slack-Bereiche wie zum Beispiel der Partition-Slack oder Disk-Slack.

Die File Slack Analyse ermöglicht dem Ermittler unter Umständen auf Inhalte zuzugreifen, welcher der Täter bereits gelöscht hat.


\subsection{Timeline-Analyse}
Bei der Timeline-Analyse werden die letzten Aktivitäten, welche auf dem System durchgeführt wurden, in ein zeitlich logische Abfolge gebracht. Bei der Herstellung einer Verbindung zu anderen Beweisen ist eine allfällige Abweichung der Systemzeit von der Referenzzeit zu beachten. Die Timeline-Analyse ist häufig der erste Ansatzpunkt einer Ermittlung. Durch die Analyse kann festgestellt werden, was undder Täter auf dem System gemacht / verändert / installiert hat. Ausgehend von dem entstehenden Zeitstrahl können weitere, vertiefte Analysen durchgeführt werden. Ein wichtiger Baustein der Timeline-Analyse ist die Auswertung der MAC-Time der Dateien und Ordner. Die MAC-Time setzt sich aus folgenden Elementen zusammen:

\begin{itemize}
\item Modification Time\\
Zeitpunkt der letzten Modifikation (Schreiben), Der Zeitstempel ändert sich bei folgenden Aktionen nicht: Kopieren, Verschieben, Umbenennen, Veränderung Dateiattribute
\item Access-Time\\
Zeitpunkt des letzten Zugriffes (Lesen / Ausführen), Der Zeitstempel wird auch verändert, wenn Metadaten oder Dateiinhalte angezeigt werden
\item Creation-Time (Windows)\\
Zeitpunkt der Erstellung der Datei, Der Zeitstempel wird bei Erstellung einer Kopie aktualisiert. Beim Verschieben einer Datei / Ordner wird der Zeitstempel nicht aktualisiert.
\item Change-Time (Unix)\\
Zeitpunkt der Veränderung bestimmter Metadaten der Datei
\end{itemize}

Nicht jede Aktion löst auf der Datei selbst eine Veränderung der MAC-Time aus. Unter Linux bewirkt die Verschiebung einer Datei eine Veränderung der MAC-Time des Verzeichnises, aber nicht der Datei selbst. Die MAC-Time kann jedoch relativ einfach durch den Angreifer, beziehungsweise durch Anti-Forensik-Tools manipuliert oder unbrauchbar gemacht werden. Eine weitere Schwierigkeit besteht darin, dass die MAC-Time sich je nach Betriebssystem anders verhält.


\subsubsection{Sleuth Kit}
\begin{enumerate}
\item Dateinformationen sammeln
\begin{lstlisting}
fls -f <Filesystem> -m <Path> -r <MountPoint>/<PathToimage> > body.fls
fls -f linux-ext2 -m / -r /mnt/images/hda7.dd > body.fls
\end{lstlisting}

\item Metadaten sammeln
\begin{lstlisting}
ils -f <Filesystem> -m <MountPoint>/<PathToImage> >> body.fls
ils -f linux-ext2 -m /mnt/images/hda7.dd >>body.fls
\end{lstlisting}

\item Gemeinsame Auswertung
\begin{lstlisting}
mactime -b body.fls
\end{lstlisting}
\end{enumerate}

\subsubsection{log2timeline}
Das Tool \textit{log2timeline} ist in der Lage Zeitlinien von verschiedensten Log-Dateien zu erstellen. Darunter die Logs des Apache WebServers, Firefox, Chrome, Windows-Ereignisprotokolle, Mactime-formatierte Dateien und viele mehr.

\begin{lstlisting}
> log2timeline -z CET -f apache_access -o sqlite -w /case/1234/mactime.sqlite /mnt/image/avar/log/apache2
> log2timeline -z CET -f <InputModule> -o <OutputModule> -w <OutputPath>
\end{lstlisting}

Das Tool \textit{log2timeline} besitzt viele Optionen und Parameter. Eine Vereinfachung des Tools stellt \textit{log2timeline-sift} dar. Eine Weiterentwicklung und Optimierung von \textit{log2timeline} wird unter dem Namen \textit{plaso} entwickelt. Die gesammelten Daten können entweder mit einem Forensik-Tool oder aber einer Anwendung zum Erstellen von Diagrammen und Statistiken grafisch dargestellt werden. Unter Linux können die Daten zum Beispiel mit Hilfe von \textit{GnuPlot} visualisiert werden.


\subsection{Analyse von Auslagerungsdateien}
Fast alle Betriebssysteme kennen das Prinzip der Auslagerungsdatei, bzw. Swap-Datei. Diese Auslagerungsdatei erweitert entweder den physisch nutzbaren Arbeitsspeicherbereich oder dient der Auslagerung von kurzfristig nicht benötigten Speicherinhalten. Dieser Swap-Bereich ist entweder eine Datei oder ein eigenes physisches oder virtuelles Dateisystem. Unter Windows wird das Page-File (früher Swap-File) beim Shutdown nicht gelöscht und kann somit bei einer Analyse interessante Informationen beinhalten. Wird ein System in den Ruhezustand, beziehungsweise Suspend-to-Disk-Modus versetzt, wird der gesamte Arbeitsspeicherinhalt auf die Festplatte gesichert. Dieser wird bei Reaktivierung wieder geladen, um den Zustand des Systemes wiederherzustellen. Unter Windows heisst diese Datei \textit{hyberfil.sys} und liegt im Wurzelverzeichnis des Systemlaufwerkes.



\subsection{Suche nach Rootkits}
Die Suche nach Rootkits auf einem System kann sich unter Umständen als sehr schwierig und zeitintensiv herausstellen. Handelt es sich um ein Standard-Rootkit gibt es einige Tools, welche die Rootkits anhand von File- und Hash-Analysen aufspüren können. 


\subsubsection{chkrootkit}
\begin{lstlisting}
> chkrootkit
\end{lstlisting}

\subsubsection{rkhunter}
\begin{lstlisting}
> rkhunter --check
\end{lstlisting}


\subsection{Systemprotokolle}
Systemprotokolle bieten in der Regel gute Hinweise auf einen zukünftigen oder bereits erfolgten Angriff. Die Analyse der Systemprotokolle ist meistens nicht Teil der Post-Mortem-Analyse, da der Angriff erst durch die Systemprotokolle entdeckt wird. In den Systemprotokollen lassen sich die Meldungen grundsätzlich in drei Kategorien einteilen. Zum einen die normalen Meldungen aus dem Tagesbetrieb und zum anderen kritische und unbekannte Meldungen, welche einen Hinweis auf einen Angriff darstellen können. Weitere Informationen zu diesem Thema sind im Kapitel \ref{sec:IncidentDetection} \nameref{sec:IncidentDetection} aufgezeigt.



\subsection{Untersuchung der Shell (Bash)}
Die Untersuchung der Shell kann weitere wertvolle Informationen liefern. Zum einen kann die MAC-Time der Shell selbst untersucht werden. Zum anderen können die von der Shell verwendeten Dateien untersucht werden. Dazu gehören die Dateien \textit{.bash\_profile} und \textit{.bashrc}, welche die Befehle enthalten, welche bei einem Start der Shell ausgeführt werden. Die interessantere Datei ist die Datei \textit{.bash\_history}. Diese Datei enthält den Audit-Trail (Histroy) der eingegebenen Befehle. Angreifer verändern diese Datei oft so, dass diese einen Link auf die Datei \textit{/dev/null} darstellt. Alles was unter Linux nach \textit{/dev/null} geschrieben wird, ist unwiderruflich verloren. Allenfalls weitere Hinweise könnte die Datei \textit{.bash\_logout} liefern, welche die Befehle enthält, welche beim Verlassen der Shell ausgeführt werden.

Es kann sich auch lohnen das Verzeichnis \textit{/etc/skel} einer genaueren Analyse zu unterziehen, da die Standard-Dateien enthält, welche beim Anlegen eines neuen Benutzers kopiert werden.
	

\subsection{Untersuchung der Druckerjobs und der Druckerqueue}
Die vom System aufgegebenen Druckerjobs können interessante Informationen enthalten. Auf älterne Unix-Systemen sind die entsprechenden Log-Dateien unter \textit{/vaR/log/lpr.log} zu finden. Auf neueren Systemen unter \textit{/var/log/cups}. Der Ort der Log-Datei kann allenfalls auch durch ein Überschreiben der Konfiguration im Verzeichnis \textit{/etc} geändert worden sein. Die Kopien der gedruckten Dateien können im Verzeichnis \textit{/var/spool}, beziehungsweise \textit{/var/spool/cups} gefunden werden. Die Analyse der Druckjobs und der Druckerqueue kann einen guten Ansatzpunkt in der Timeline-Analyse darstellen. Die Log-Einträge können zum Beispiel Hinweise auf eine gelöschte Datei beinhalten und bieten somit einen ersten Anhaltspunkt für die Suche der Datei im Speicherbereich.



\subsection{Untersuchung der Dateien / Dateiendungen}
Oft wird eine Datei über deren Dateiendung identifiziert. Wurde diese absichtlich verändert, kann der Dateityp weiterhin bestimmt werden. Dies wird durch File-Signatur, beziehungsweise den File-Header, ermöglicht. Durch eine Signaturanalyse können auf einem System Dateien gefunden werden, bei denen Dia Signatur nicht mit der Dateiendung übereinstimmt. Die Ergebnisse einer solchen Analyse sind jedoch mit Vorsicht zu geniessen, da der File-Header auch falsch sein kann. Ein Beispiel wäre eine Text (txt) Datei mit dem Inhalt "`FLV ist ein cooles Format"'. Die Signatur würde dann nahelegen, dass es sich um ein File im "`FLV"' Format handelt. In Wirklichkeit handelt es sich jedoch um ein txt-File.


\subsubsection{Linux}
Der File Befehl ermittelt gestützt auf das \textit{magic} File den File-Header der Datei. Diese Datei befindet sich oft in einem der folgenden Verzeichnisse: \textit{/usr/magic}, \textit{/etc/gnome-vfs-mime-magic}, \textit{/usr/share/mimelnk/magic}.

\begin{lstlisting}
> file <PathToFile>

> file ./Test.txt
Test.txt: Macromedia Flash Video
\end{lstlisting}

\subsection{Datei- und Verzeichnisrechte}
Auch die Untersuchung der Datei-Verzeichnisrechte, beziehungsweise deren Veränderung der MAC-Time, kann wichtige Hinweise für die Analyse liefern.

\subsubitem{Linux}
\begin{lstlisting}
>  -lrta /etc/
> ls -lrta /bin
> ls -lrta /sbin
> ls -Rlrta /usr
> ls -Rlrta /var
> ls -Rlrta /dev
> ls -Rlrta /home
> ls -Rlrta /lib
\end{lstlisting}

\subsection{Analyse des RAM-Dumps}
Die Auswertung von RAM-Dumps kann sehr zeitaufwändig sein, da sich die Struktur des RAMs grundlegend von der Struktur von normalen Filesystemen unterscheidet. Hinzu kommt, dass im RAM oft nur Fragemente von Dateien abgelegt sind.

\subsubsection{Volatility}
\textit{Volatility} ist ein Framework zur Analyse von RAM-Dumps. Das Framework bietet unzählige Optionen und Einstellmöglichkeiten. Nachfolgend werden einige grundlegende Befehle aufgezeigt.

\begin{itemize}
\item Allgemeine Informationen
\begin{lstlisting}
> python vol.py -f <PathToImage> imageinfo
\end{lstlisting}

\item Liste aller Prozesse
\begin{lstlisting}
> python vol.py --profile=<Profile> -f <PathToImage> pslist
\end{lstlisting}

\item Prozesse als Baumstruktur
\begin{lstlisting}
> python vol.py --profile=<Profile> -f <PathToImage> pstree
\end{lstlisting}

\item Liste von Dateiobjekten
\begin{lstlisting}
> python vol.py --profile=<Profile> -f <PathToImage> filescan
\end{lstlisting}

\end{itemize}

\subsection{Konvertierung von Images}
Ab und zu kann es notwendig sein, die erstellten Images in ein anders Format zu konvertieren. 

\subsubsection{ewfacquire}
\begin{itemize}
\item Konvertierung von DD nach E01
\begin{lstlisting}
> ewfacquire -t <PathToSourceImage.dd> <PathToTargetImage.E01>
\end{lstlisting}

\item Konvertierung von E01 nach DD
\begin{lstlisting}
> ewfeport <PathToSourceImage.E01>
\end{lstlisting}
\end{itemize}


\subsubsection{xmount}
\begin{itemize}
\item Konvertierung von vmdk nach E01
\begin{lstlisting}
> xmount --in ewf --out vmdk <PathToSourceImage.E01> <DestinationPath>
\end{lstlisting}

\item Konvertierung von E01 nach vmdk
\begin{lstlisting}
> xmount --in vmdk --out ewf <PathToSourceDisk.vmdk> <DestinationPath>
\end{lstlisting}
\end{itemize}

\subsubsection{Weitere Tools}
Die nachfolgenden Tools verfügen ebenfalls über entsprechende Funktionalitäten:
\begin{itemize}
\item FTK Imager
\item VHD Tool
\end{itemize}



\subsection{Analyse des Master Boot Records}
Der Master Boot Record ist für den Bootvorgang von essentieller Bedeutung und kann auch bei einer forensischen Analyse hilfreiche Informationen bezüglich Partitionierung und verwendeten Dateisystemen beinhalten. Der Master Boot Record ist wie folgt aufgebaut:

\begin{itemize}
\item Bootcode (Bytes 0-439)
\item Disksignatur (Bytes 440-443)
\item Reservierter Bereich (Bytes 444-445)
\item Partitionstabelle (Bytes 446-509)
\item Signatur \textit{0x55 0xAA} (Bytes 510-511)
\end{itemize}

\subsubsection{Sicherung des Master Boot Records}
Mit Hilfe des Tools \textit{dd} oder eines ähnlichen Tools kann der Master Boot Record wie folgt gesichert werden:

\begin{lstlisting}
> dd if=<PathToSource> of=<PathToTargetFile.dd> bs=512 count=1 skip=0
\end{lstlisting}


\subsubsection{Sicherung des Master Boot Records}
Mit Hilfe des Tools \textit{dd} oder eines ähnlichen Tools kann der Master Boot Record wie folgt gesichert werden:

\begin{lstlisting}
> dd if=<PathToSource> of=<PathToTargetFile.dd> bs=512 count=1 skip=0
\end{lstlisting}


\subsubsection{Extraktion des Master Boot Records aus einem image}
\begin{lstlisting}
> dd if=<PathToSourceImage.dd> of=<PathToTargetFile.dd> bs=512 count=1 skip=0
\end{lstlisting}


\subsection{Weitere Analyse-Möglichkeiten}
Nachfolgend werden weitere Analysemöglichkeiten aufgezeigt, welche in diesem Kapitel nicht näher beschrieben werden.
\begin{itemize}
\item Analyse unbekannter Binärdateien
\item Analyse von User Aktivitäten
\item Analyse bei Verdacht auf Anti-Forensik-Techniken
\item File-Carving
\item Block-Hashing
\item Suche nach Regulären Ausdrücken (Regex)
\item Erstellen von Datei-Listen
\item Sammeln von bestimmten Dateitypen
\item Suche und Auswertung von Log-Files
\item Suche nach SUID und GID-Dateien
\item Analyse der Master File Table
\item Analyse von NTFS-Streams
\item Analyse von NTFS TxF
\item Analyse der Windows-Registry
\item Analyse der Windows UserAssist Keys
\item Analyse der Windows Prefetch-Dateien
\item Analyse von Netzwerkmitschnitten
\item NTFS-Volumen-Schattenkopien
\end{itemize}


%---------------------------------------------------------------------------------------------------------------
\section{Reporting}
Gewisse Tools und Tool-Suiten bieten eine integrierte Möglichkeit um Berichte und Dokumentationen zu generieren. 


%---------------------------------------------------------------------------------------------------------------
\section{Hinweise zu Tooleinsatz}
Nachfolgend einige Hinweise zum Einsatz von Tools bei einer forensischen Analyse:

\begin{itemize}
\item Auswahl des Tools kann Grundsatzdiskussionen zu den Ermittlungsmethoden auslösen.
\item Verständnis der unterschiedlichen Ansätze verschiedener Forensik-Tools und -Tool-Suiten.
\item Open Source vs. Kommerzielle Tools: Klassische ideologische Diskussion. Für die juristische Verwendbarkeit sind beide Ansätze legitim, sofern die gewählten Tools akzeptiert und etabliert sind.
\item Einsatz von Script-Sammlungen (Konsolen-Befehle) vs. GUI-Anwendungen. Der Einsatz von GUI-Anwendungen bietet erheblich mehr komfort als der Einsatz von Script-Sammlungen, beziehungsweise dem Absetzen von Konsolen-Befehlen. Der Nachteil der GUI-Anwendungen ist jedoch, dass diese einen höheren RAM-Bedarf haben. Daher sollte bei einer Live-Analyse auf den Einsatz von grafischen Tools wann immer möglich verzichtet werden.
\item Die einzusetzenden Tools sind stark von der jeweiligen Situation und dem zu untersuchenden System abhängig. Die Toolsammlung sollte daher jeweils den Umständen entsprechend angepasst werden.
\item Der Umgang mit den verschiedenen Tools sollte regelmässig geübt werden, damit bei der Untersuchung schnell, effizient und korrekt gearbeitet werden kann.
\item Bei der Live-Analyse sollten immer nur statisch vorkompilierte Systembefehle verwendet werden. Andernfalls ist die Korrektheit der so gesammelten Daten nicht gewährleistet.
\item Das Analyse-System des Ermittlers sollten immer abgesichert sein.
\item Die Ergebnisse der Analyse sollten verschlüsselt abgespeichert werden.
\end{itemize}



%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\section{Tool-Suiten und Toolsammlungen}
Nachfolgend werden enige Tool-Suiten und Toolsammlungen für die forensische Analyse aufgelistet:

\begin{itemize}
\item F.R.E.D. (First Responder's Evidence Disk)\\
Schnelle Sammlung von Statusinformationen auf Live-Systemen, statisch vorkompilierte Vefehle, anpassbares und erweiterbares Batch- / Shell-Script

\item Incident Response Collection Report (IRCR)\\
Sammlung von Werkzeugen zur Sammlung kritischer Systemdaten, Tool für Windows, Verwendung von Systembefehlen zur Sammlung der Daten (hinterlässt Spuren auf dem System)

\item Windows Forensic Toolchest (WFT)\\
Tool-Sammlung zur Analyse von Live-Systemen unter Windows, Hinterlässt wenige Spuren, Flexible Anpassung der generierten Reports

\item Live View\\
Java-Anwendung zur Generierung einer read-only VM-Ware Virtual Machiene aus einem dd Image oder einem physischen Datenträger unter Windows.

\item EnCase \\
Windows-Anwendung zur Analyse von verschiedenen Dateisystemen (Windows, Mac OS, Linux, Solaris, AIX, HP UX, ...), Automatisierung von verschiedenen Aufgaben via EnScript, Breite Palette an Tools, Analyse von verschiedensten Anwendungsdaten, Mehrsprachig, erhältlich als Enterprise-Version

\item F.I.R.E\\
Freie Toolsammlung zur forensischen Analyse und Datenrettung. Beinhaltet das Sleuth Kit, den Autopsy Forensic Browser und viele mehr, geeignet für die Incident Response an Live-Systemen und Penetrationstests, Erhältlich für Windows, Linux und Solaris, Keine Wartung / Weiterentwicklung

\item Knoppix Security Tools Distribution\\
Sammlung von Security-Tools für Penetrations-Tests, Forensische Analysen und Incident-Response, Keine Wartung / Weiterentwicklung

\item Helix
Forensisches Toolkit inklusive Case-Management (Enterprise-Version), statisch vorkompilierte Dateien für LInux, Solaris und Windows, Support durch Hersteller, hoher Integrationsgrad, Live-Response für Windows


\item ForensiX-CD\\
Toolsammlung für Windows und Linux, Statisch vorkompilierte Systemprogramme

\item C.A.I.N.E und WinTaylor \\
Live-CD für Windows (WinTaylor) und Linux (C.A.I.N.E), Sammlung von Incident-Response-Tools, Benötigt als Basis Visual Basic 6 (entsprechende Bibliotheken werden auf dem System benötigt)

\item DEFT und DEFT-Extra\\
Werkzeug-Sammlung für die Live-Response unter Linux und Windows.

\item Forensic Acquisition Utilities \\
Tool-Sammlung für die forensische Analyse, beziehungsweise Datenesammlung

\item AccessData Forensic Toolkit \\
Komplette Analyseumgebung für Unix- und Windows-Dateisysteme, Mehrbenutzerfähig (via Datenbank-Server)

\item The Coroner's Toolkit and TCTUtils\\
Tool-Sammlung für die Post-Mortem Analyse von Unix-Systemen.

\item The Sleuth Kit\\
Sammlung von diversen Tools zur forensischen Analyse, Unterstützt eine breite Palette an Formaten.

\item Autopsy Forensic Browser\\
Grafische Oberfläche für "`The Leuth Kit"', Neuste Version nur für Windows verfügbar

\end{itemize}




